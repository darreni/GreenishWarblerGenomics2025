---
title: "Greenish Warbler Genomic Analysis"
author: "Darren Irwin"
date: "9/10/2023"
execute:
  echo: true
format:
  html:
    code-fold: false
  pdf:
    keep-tex: false
    monofont: "JuliaMono"
jupyter: julia-1.10
---

This page contains notes and code describing the data analysis for a manuscript on Greenish Warbler genomics. I've been working with the data for several years, and the R and then Julia code has been in development for a while. This is a Quarto notebook, which can run and display the results of Julia (or other) code blocks, along with text narration, and output in html, pdf, Word, etc.

The Julia code here is loosely based on R code written for Greenish Warbler analysis (Irwin et al. 2016), and then the North American warbler analyses (Irwin et al. 2019), and then my (unpublished) 2019 Greenish Warbler analysis. Most recently, this was adapted from the scripts called GW2022_R_analysis_script.R and IrwinLabGenomicsAnalysisScript.jl but has had a lot of opimizations since then.
The SNP data here are a result of GBS reads mapped to our new 2022 Biozeron genome assembly for a greenish warbler from southern China.

## Load packages

If running this for the first time, you will need to load packages used in the script, so run what is in this section below. It will take some time to install and precompile the packages:

```julia
import Pkg; Pkg.add("CSV") # took less than a minute
Pkg.add("DataFrames") # took about a minute
Pkg.add("Plots") # seems to install and working more simply than Makie (but less powerful)
Pkg.add("Haversine") # for great circle (Haversine) distances
Pkg.add("Distributions") # this seemed to fix a problem installing GLMakie
Pkg.add("MultivariateStats")
Pkg.add("StatsBase")
Pkg.add("Impute")
Pkg.add("JLD2")
Pkg.add("CairoMakie")
Pkg.add("PrettyTables") # for printing nice tables to REPL
Pkg.add(path="/Users/darrenirwin/.julia/dev/SNPlots.jl")
```

Now actually load those packages into the Julia session:

```{julia}
using CSV # for reading in delimited files
using DataFrames # for storing data as type DataFrame
using Haversine # for calculating Great Circle (haversine) distances between sites
using Statistics # for mean() function
using MultivariateStats # for Principal Coordinates Analysis (multidimensional scaling)
using DelimitedFiles # for reading delimited files (the genotypic data)
using Impute # for imputing missing genotypes
using JLD2 # for saving data
using CairoMakie # for plots
using PrettyTables
CairoMakie.activate!()  # this makes CairoMakie the main package for figures (in case another already loaded)
```

Load my custom package `SNPlots`:

```{julia}
# include("SNPlots.jl") # load file containing custom-built functions
using SNPlots # actually make SNPlots module available with SNPlots.functionName(),
# or if functions are exported from SNPlots then they are available.
```

Test Julia:

```{julia}
x = 1; y = 2; z = x+y
println("z = ", z)
```

(If Quarto is calling Julia properly, you will see `z = 3` as the output of the code block above.)

Choose working directory:

```{julia}
repoDirectory = pwd() # this gets the starting working directory, for later use
dataDirectory = "/Users/darrenirwin/Dropbox/Darren's current work/"
cd(dataDirectory)
```

#### Load the chromosome (scaffold) lengths
The code below will load a fasta index file for the reference genome, and then make a dictionary (a look-up table) where the key is the scaffold name and value is the chromosome length. This will be used in the genotype-by-individual figures.

```{julia}
cd(repoDirectory)
scaffold_info_filepath = "metadata/GW2022ref.fa.fai" # a fasta index file for the reference genome
scaffold_info = DataFrame(CSV.File(scaffold_info_filepath; header=["name", "length", "offset", "linebases", "linewidth"], types=[String, Int, Int, Int, Int]))
scaffold_lengths = Dict(scaffold_info.name .=> scaffold_info.length)
cd(dataDirectory)
``` 

### Set up file directories and names

```{julia}
# choose path and filename for the 012NA files
baseName = "GW_genomics_2022_with_new_genome/GW2022_GBS_012NA_files/GW2022_all4plates.genotypes.SNPs_only.whole_genome"
filenameTextMiddle = ".max2allele_noindel.vcf.maxmiss"
# indicate percent threshold for missing genotypes for each SNP--
# this was set by earlier filtering, and is just a record-keeper for the filenames:
missingGenotypeThreshold = 60 
filenameTextEnd = ".MQ20.lowHet.tab"
tagName = ".Dec2023."   # choose a tag name for this analysis
# indicate name of metadata file, a text file with these column headings:
# ID	location	group	Fst_group	plot_order
metadataFile = "GW_genomics_2022_with_new_genome/GW_all4plates.Fst_groups.txt"
```

### List the scaffolds to be imputed (for later inclusion in PCA)

```{julia}
chromosomes_to_process = vec(["gw2",
                            "gw1",
                            "gw3",
                            "gwZ",
                            "gw1A",
                            "gw4",
                            "gw5",
                            "gw7",
                            "gw6",
                            "gw8",
                            "gw9",
                            "gw11",
                            "gw12",
                            "gw10",
                            "gw13",
                            "gw14",
                            "gw18",
                            "gw20",
                            "gw15",
                            "gw1B",
                            "gws100",
                            "gw17",
                            "gw19",
                            "gws101",
                            "gw4A",
                            "gw21",
                            "gw26",
                            "gws102",
                            "gw23",
                            "gw25",
                            "gws103",
                            "gw22",
                            "gws104",
                            "gw28",
                            "gw27",
                            "gw24",
                            "gws105",
                            "gws106",
                            "gws107",
                            "gws108",
                            "gws109",
                            "gws110",
                            "gws112"]);
```

### Set up function to correct the names of GBS runs:

```{julia}
function correctNames(metadataColumn)
    metadataColumn_corrected = replace(metadataColumn, 
                        "GW_Armando_plate1_TTGW05_rep2" => "GW_Armando_plate1_TTGW05r2",
                        "GW_Lane5_NA3-3ul" => "GW_Lane5_NA3",
                        "GW_Armando_plate1_TTGW_15_05" => "GW_Armando_plate1_TTGW-15-05",
                        "GW_Armando_plate1_TTGW_15_07" => "GW_Armando_plate1_TTGW-15-07",
                        "GW_Armando_plate1_TTGW_15_08" => "GW_Armando_plate1_TTGW-15-08",
                        "GW_Armando_plate1_TTGW_15_09" => "GW_Armando_plate1_TTGW-15-09",
                        "GW_Armando_plate1_TTGW_15_01" => "GW_Armando_plate1_TTGW-15-01",
                        "GW_Armando_plate1_TTGW_15_02" => "GW_Armando_plate1_TTGW-15-02",	
                        "GW_Armando_plate1_TTGW_15_03" => "GW_Armando_plate1_TTGW-15-03",
                        "GW_Armando_plate1_TTGW_15_04" => "GW_Armando_plate1_TTGW-15-04",
                        "GW_Armando_plate1_TTGW_15_06" => "GW_Armando_plate1_TTGW-15-06",
                        "GW_Armando_plate1_TTGW_15_10" => "GW_Armando_plate1_TTGW-15-10",
                        "GW_Armando_plate2_TTGW_15_01" => "GW_Armando_plate2_TTGW-15-01",
                        "GW_Armando_plate2_TTGW_15_02" => "GW_Armando_plate2_TTGW-15-02",
                        "GW_Armando_plate2_TTGW_15_03" => "GW_Armando_plate2_TTGW-15-03",
                        "GW_Armando_plate2_TTGW_15_04" => "GW_Armando_plate2_TTGW-15-04",
                        "GW_Armando_plate2_TTGW_15_06" => "GW_Armando_plate2_TTGW-15-06",
                        "GW_Armando_plate2_TTGW_15_10" => "GW_Armando_plate2_TTGW-15-10") 
end
```


### The above should be run before any of the other Quarto pages are run





##############
##############

## _OK, let's load the genomic data!_


```{julia}
# load metadata
metadata = DataFrame(CSV.File(metadataFile)) # the CSV.File function interprets the correct delimiter
num_metadata_cols = ncol(metadata)
num_individuals = nrow(metadata) 
# read in individual names for this dataset
individuals_file_name = string(baseName, filenameTextMiddle, missingGenotypeThreshold, filenameTextEnd, ".012.indv")
ind = DataFrame(CSV.File(individuals_file_name; header=["ind"], types=[String])) 
indNum = size(ind, 1) # number of individuals
if num_individuals != indNum
    println("WARNING: number of rows in metadata file different than number of individuals in .indv file")
end
# read in position data for this dataset
position_file_name = string(baseName, filenameTextMiddle, missingGenotypeThreshold, filenameTextEnd, ".012.pos")
pos_whole_genome = DataFrame(CSV.File(position_file_name; header=["chrom", "position"], types=[String, Int]))
# read in genotype data
column_names = ["null"; string.("c.", pos_whole_genome.chrom, ".", pos_whole_genome.position)]    
genotype_file_name = string(baseName, filenameTextMiddle, missingGenotypeThreshold, filenameTextEnd, ".012minus1") 
@time if 1 <= indNum <= 127   
    geno = readdlm(genotype_file_name, '\t', Int8, '\n'); # this has been sped up dramatically, by first converting "NA" to -1
elseif 128 <= indNum <= 32767
    geno = readdlm(genotype_file_name, '\t', Int16, '\n'); # this needed for first column, which is number of individual; Int16 not much slower on import than Int8
else
    print("Error: Number of individuals in .indv appears outside of range from 1 to 32767")
end
loci_count = size(geno, 2) - 1   # because the first column is not a SNP (just a count from zero)
print(string("Read in genotypic data at ", loci_count," loci for ", indNum, " individuals. \n"))
```


### Check that individuals are same in genotype data and metadata 
```{julia}
ind_with_metadata = hcat(ind, metadata)
println(ind_with_metadata)
println()  # prints a line break 
if isequal(ind_with_metadata.ind, ind_with_metadata.ID)
    println("GOOD NEWS: names of individuals in metadata file and genotype ind file match perfectly.")
else
    println("WARNING: names of individuals in metadata file and genotype ind file do not completely match.")
end
```

## Filtering 

#### Filter out duplicate runs (indicated with `_rep` in `Fst_group` column)

```{julia}
    selection = occursin.("_rep", ind_with_metadata.Fst_group)
    println("""Filtering out these runs because they are duplicates of another,
    according to having "rep" in Fst_group: """)
    display(ind_with_metadata.ind[selection])
    ind_with_metadata_indFiltered = ind_with_metadata[Not(selection), :];
    geno_indFiltered = view(geno, Not(selection), :);  # use of view() avoids copying large memory object
```

#### Filter specific individuals

If there are certain individuals that we want to filter out prior to any additional analysis, we can do so here by setting filter to `true` and specifying the individual row numbers in `filter_out_inds`:

```{julia}
filter = true
# Specify individuals to filter out:
filter_out_inds = ["GW_Liz_GBS_P_fusc", "GW_Liz_GBS_P_h_man", "GW_Liz_GBS_P_humei", "GW_Liz_GBS_P_inor", "GW_Liz_GBS_S_burk"]
if filter
    selection = map(in(filter_out_inds), ind_with_metadata_indFiltered.ind)
    filtered_out = ind_with_metadata_indFiltered.ind[selection]
    ind_with_metadata_indFiltered = ind_with_metadata_indFiltered[Not(selection), :]
    geno_indFiltered = view(geno_indFiltered, Not(selection), :)
    println("Specific individuals filtered out as requested: ")
    display(filtered_out)
else
    println("No specific individuals filtered (because filter not true)")
end
```

#### Filter individuals based on missing genotypes 

Here we determine number of missing SNPs per individual (40% for this round), and filter out those individual datasets with more than a certain percent of missing SNPs:

```{julia}
SNPmissing_percent_allowed_per_ind = 40   # this is the percentage threshold
threshold_missing = loci_count * SNPmissing_percent_allowed_per_ind/100
numMissings = sum(geno_indFiltered .== -1, dims=2)
ind_with_metadata_indFiltered.numMissings .= numMissings
selection = vec(numMissings .<= threshold_missing) # the vec command converts to BitVector rather than BitMatrix--important below
println("Filtering out these individuals based on too many missing genotypes: ")
filtered_inds = ind_with_metadata_indFiltered.ind[selection.==false]
println(DataFrame(filtered_inds = filtered_inds)) # did this to print all lines
ind_with_metadata_indFiltered = ind_with_metadata_indFiltered[selection, :]
geno_indFiltered = view(geno_indFiltered, selection, :);
println()
println("Here are the remaining individuals: ")
println(DataFrame(ind_with_metadata_indFiltered))
```

#### Filter SNPs with too many missing genotypes:
```{julia}
# (remember that first column is arbitrary row number in input file)
missing_genotypes_per_SNP = sum(geno_indFiltered .== -1, dims=1)
missing_genotypes_percent_allowed_per_site = 5   # this is the percentage threshold
threshold_genotypes_missing = size(geno_indFiltered)[1] * missing_genotypes_percent_allowed_per_site/100
selection = vec(missing_genotypes_per_SNP .<= threshold_genotypes_missing)
geno_ind_SNP_filtered = geno_indFiltered[:, selection] 
pos_SNP_filtered = pos_whole_genome[selection[Not(1)],:]  # the Not(1) is needed because first column in geno is arbitrary row number
println("Started with ", size(geno_indFiltered, 2)-1, " SNPs.
After filtering SNPs for no more than ", missing_genotypes_percent_allowed_per_site, "% missing genotypes, ", size(geno_ind_SNP_filtered, 2)-1, " SNPs remain." )
```

#### 2nd round of filtering individuals

I added this in August 2023, to improve accuracy of imputation-based PCA, because I noticed outliers tended to have more missing data. Now I only allow up to 10% missing SNPs per individual.

```{julia}
SNPmissing_percent_allowed_per_ind_round2 = 10   # this is the percentage threshold
threshold_missing = (size(geno_ind_SNP_filtered, 2) - 1) * SNPmissing_percent_allowed_per_ind_round2/100
numMissings = sum(geno_ind_SNP_filtered .== -1, dims=2)
selection = vec(numMissings .<= threshold_missing) # the vec command converts to BitVector rather than BitMatrix--important below
geno_ind_SNP_ind_filtered = geno_ind_SNP_filtered[selection, :]
println("Filtering out these individuals based on too many missing genotypes: ")
filtered_inds = ind_with_metadata_indFiltered.ind[selection.==false]
println(DataFrame(filtered_inds = filtered_inds)) # did this to print all lines
ind_with_metadata_indFiltered = ind_with_metadata_indFiltered[selection, :]
println("This leaves ", size(geno_ind_SNP_ind_filtered, 1), " individuals and ", size(geno_ind_SNP_ind_filtered, 2)-1, " loci, 
with no individuals missing more than ", SNPmissing_percent_allowed_per_ind_round2, "% of genotypes
and no loci missing in more than ", missing_genotypes_percent_allowed_per_site, "% of individuals.")
```

Remove the first column of the genotype matrix (which was an initial row number):
```{julia}
genosOnly_ind_SNP_ind_filtered = geno_ind_SNP_ind_filtered[:, Not(1)]
```

### Polish a few individual names (for more readable graphs):

```{julia}

ind_with_metadata_indFiltered.ind = correctNames(ind_with_metadata_indFiltered.ind)

ind_with_metadata_indFiltered.ID = correctNames(ind_with_metadata_indFiltered.ID)

```

---------------------

# Calculate distances around ring

The locations around the ring (assuming barrier in North) can be graphed against genomic PC1 (or other variables).

#### Load lat/long data

```{julia}
cd(repoDirectory)
latlong_filepath = "metadata/GW_locations_LatLong_2023.txt"
latlongs = DataFrame(CSV.File(latlong_filepath))
print(latlongs)
```

#### Make a quick plot to inspect latlong data:

```{julia}
f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title = "Research locations",
    xlabel = "longitude (E)",
    ylabel = "latitude (N)"
)
scatter!(latlongs.long_E, latlongs.lat_N)
text!(latlongs.long_E, latlongs.lat_N; text = latlongs.location_short)
f
```

#### remove "Green warbler" _nitidus_

_Phylloscopus [t.] nitidus_ is outside of the main ring, so remove these samples from this analysis: 

```{julia}
latlongs2 = latlongs[Not(latlongs.subspecies .== "nitidus"), :];
print(latlongs2)
```

#### Make a matrix of great circle distances 

These are Haversine distances, assuming spherical Earth which is really close:

```{julia}
geoPoints = GeoLocation.(latlongs2.long_E, latlongs2.lat_N)
# this next line is so neat--uses list comprehension to make a matrix of pairwise calculations
distances = [(HaversineDistance(geoPoints[i], geoPoints[j])/1000) for i in eachindex(geoPoints), j in eachindex(geoPoints)]
```

#### Now adjust distances to assume no gene flow through centre of ring.

```{julia}
# get some key distances
function getIndex(name; nameVector = latlongs2.Location_name)
    findfirst(isequal(name), nameVector)
end

index_AA = getIndex("Ala_Archa")
index_NR = getIndex("Naran_Pakistan")
index_LN = getIndex("Langtang")
index_GG = getIndex("Gongga")
index_XN = getIndex("Xining")
index_BJ = getIndex("Beijing")
index_last = nrow(latlongs2)

dist_NR_to_LN = distances[index_NR, index_LN]
dist_LN_to_GG = distances[index_LN, index_GG]
dist_GG_to_BJ = distances[index_GG, index_BJ]

# This next part will assume locations in the input file are arranged in order around ring:
distsAroundRing = Matrix{Float32}(undef, size(distances)[1], size(distances)[2])
# accept all distances within viridanus:

# function for accepting straight-line great circle dists as distances between sets of sites
acceptDists = function(straightGreatCircleDists, start, finish, distsAroundRing)
    distsAroundRing[start:finish, start:finish] = straightGreatCircleDists[start:finish, start:finish]
    return(distsAroundRing)
end

# accept all distances within viridanus:
distsAroundRing = acceptDists(distances, 1, index_AA, distsAroundRing)

# accept dist from AA to NR:
distsAroundRing = acceptDists(distances, index_AA, index_NR, distsAroundRing)

# accept all distances from NR to LN:
distsAroundRing = acceptDists(distances, index_NR, index_LN, distsAroundRing)

# accept dist from LN to GG:
distsAroundRing = acceptDists(distances, index_LN, index_GG, distsAroundRing)

# accept dists between GG, EM, XN, BJ:
distsAroundRing = acceptDists(distances, index_GG, index_BJ, distsAroundRing)

# accept all distances within plumbeitarsus:
distsAroundRing = acceptDists(distances, index_BJ, index_last, distsAroundRing)

# function for adding up distances measured through certain sites:
addDists = function(set1start, set1end, set2start, set2end, distsAroundRing)
    firstDists = repeat(distsAroundRing[set1start:(set1end-1), set1end], 1, set2end-set2start+1)
    secondDists = repeat(transpose(distsAroundRing[set1end, set2start:set2end]), set1end-set1start, 1)
    totalDists = firstDists + secondDists
    distsAroundRing[set1start:(set1end-1), set2start:set2end] = totalDists
    distsAroundRing[set2start:set2end, set1start:(set1end-1)] = transpose(totalDists)
    return(distsAroundRing)
end

# dists from viridanus to NR are sum of dists to AA plus AA to NR:
distsAroundRing = addDists(1, index_AA, index_NR, index_NR, distsAroundRing)

# dists from "northwest of PK" to Himalayas are sum of ringdists to NR plus NR to locations up to LN:
distsAroundRing = addDists(1, index_NR, index_NR+1, index_LN, distsAroundRing)

# dists from "west / northwest of LN" to GG are sum of dists to LN plus LN to EM:
distsAroundRing = addDists(1, index_LN, index_GG, index_GG, distsAroundRing)

# dists from "west / northwest of EM" to China are sum of dists to GG plus GG to (EM, XN, BJ):
distsAroundRing = addDists(1, index_GG, index_GG, index_BJ, distsAroundRing)

# dists from "west of BJ" to east Siberia are sum of dists to BJ plus BJ to other plumbeitarsus:
distsAroundRing = addDists(1, index_BJ, index_BJ+1, index_last, distsAroundRing);
```

#### Do Principal Coordinates Analysis on the distances around the ring

This produces a single location axis around ring, going from west Siberia south, then east, then north to east Siberia.

```{julia}
PCO_around_ring = fit(MDS, distsAroundRing; distances=true, maxoutdim=1)
# add this as a column to the data frame:
latlongs2.LocationAroundRing = vec(-predict(PCO_around_ring))
# another way: 
# latlongs2[:, :LocationAroundRing] = vec(-predict(PCO_around_ring))
latlongs2[:, [:location_short, :LocationAroundRing]]
println(latlongs2[:, [:location_short, :LocationAroundRing]])
```

Add these ring locations to the metadata table:

```{julia}
ind_with_metadata_indFiltered.ring_km .= NaN  # pre-allocate the column
for i in axes(latlongs2, 1)
    match_indices = findall(ind_with_metadata_indFiltered.location .== latlongs2.location_short[i])
    ind_with_metadata_indFiltered.ring_km[match_indices] .= latlongs2.LocationAroundRing[i];
end
```

# Make a table of locations and groups of individuals included after filtering

```{julia}
gdf = groupby(ind_with_metadata_indFiltered, [:location, :Fst_group])
sample_origin_summary = combine(gdf, nrow)
print(sample_origin_summary)
# to save as comma-delimited text:
# CSV.write("GW2023_sample_origin_summary.txt", sample_origin_summary; delim='\t')
```

## Save the filtered dataset
```{julia}
cd(dataDirectory)
filename = string(baseName, tagName, ".ind_SNP_ind_filtered.jld2")
jldsave(filename; genosOnly_ind_SNP_ind_filtered, ind_with_metadata_indFiltered, pos_SNP_filtered)
println("Saved the filtered data.")
```

HERE WILL PASS THE DATA OFF TO OTHER QUARTO PAGES, TO LOAD DATA AS BELOW:

## Load the filtered dataset
```julia
filename = string(baseName, tagName, ".ind_SNP_ind_filtered.jld2")
genosOnly_ind_SNP_ind_filtered = load(filename, "genosOnly_ind_SNP_ind_filtered")
ind_with_metadata_indFiltered = load(filename, "ind_with_metadata_indFiltered")
pos_SNP_filtered = load(filename, "pos_SNP_filtered")
println("Loaded the filtered data.")
```

####################


## Prepare data for Genotype-by-individual plots and PCA

For missing genotypes, change our code of `-1` to `missing`:

```{julia}
genosOnly_with_missing = Matrix{Union{Missing, Int16}}(genosOnly_ind_SNP_ind_filtered)
genosOnly_with_missing[genosOnly_with_missing .== -1] .= missing;
```


## Genotype-by-individual plots

Now, show individual genotypes for subsets of the dataset. Can choose individuals and genomic regions to plot, along with an Fst cutoff (only show SNPs with greater Fst than the cutoff).

```{julia}
groups = ["vir","plumb"]
plotGroups = ["vir","plumb_vir","plumb"]
plotGroupColors = ["blue","purple","red"]
numIndsToPlot = [100,100,100] # maximum number of individuals to plot from each group
group1 = "vir"   # these groups will determine the color used in the graph
group2 = "plumb"
groupsToCompare = "vir_plumb"
Fst_cutoff =  0.8
missingFractionAllowed = 0.2  # only show SNPs with less than this fraction of missing data among individuals
```

#### Calculate allele freqs and sample sizes (use column Fst_group)

```{julia}
freqs, sampleSizes = getFreqsAndSampleSizes(genosOnly_with_missing, ind_with_metadata_indFiltered.Fst_group, groups)
println("Calculated population allele frequencies and sample sizes")
```

#### calculate Fst 
```{julia}
Fst, FstNumerator, FstDenominator, pairwiseNamesFst = getFst(freqs, sampleSizes, groups; among=true)  # set among to FALSE if no among Fst wanted (some things won't work without it) 
println("Calculated Fst values")
```

#### limit the individuals to include in plot

```{julia}
# For this figure only, filter out individuals with lots of missing genotypes
numMissings_threshold = 800_000
selection = ind_with_metadata_indFiltered.numMissings .< numMissings_threshold
genosOnly_with_missing_selected = view(genosOnly_with_missing, selection, :)
ind_with_metadata_indFiltered_selected = view(ind_with_metadata_indFiltered, selection, :)
# now limit each group to specified numbers
genosOnly_included, ind_with_metadata_included = limitIndsToPlot(plotGroups, numIndsToPlot, genosOnly_with_missing_selected, ind_with_metadata_indFiltered_selected);
```

#### Choose the scaffold and region to show
```{julia}
chr = "gw23"
regionInfo = chooseChrRegion(pos_SNP_filtered, chr; positionMin=1, positionMax=scaffold_lengths[chr]) # this gets the maximum position for the chromosome
```

#### Now actually make the plot

```{julia}
plotInfo = plotGenotypeByIndividual(groupsToCompare, Fst_cutoff, missingFractionAllowed,
    regionInfo, pos_SNP_filtered, Fst, pairwiseNamesFst, 
    genosOnly_included, ind_with_metadata_included, freqs, plotGroups, plotGroupColors; plotTitle = "");
# plotInfo contains a tuple with: (f, plottedGenotype, locations, plottedMetadata)

if false  # set to true to save plot
    save("Figure4_upperleft_gw23GBIplot_from_Julia.png", plotInfo[1], px_per_unit = 2.0)
end 
```
  
#### choose another chromosome, and plot similarly to above
```{julia}
chr = "gw26"
regionInfo = chooseChrRegion(pos_SNP_filtered, chr; positionMin=1, positionMax=scaffold_lengths[chr]) # this gets the maximum position for the chromosome
plotInfo = plotGenotypeByIndividual(groupsToCompare, Fst_cutoff, missingFractionAllowed,
    regionInfo, pos_SNP_filtered, Fst, pairwiseNamesFst,
    genosOnly_included, ind_with_metadata_included, freqs, plotGroups, plotGroupColors; plotTitle = "");
if false  # set to true to save plot
    save("Figure4_upperright_gw26GBIplot_from_Julia.png", plotInfo[1], px_per_unit = 2.0)
end 
```

#### Make a GBI plot to illustrate variation along west side of ring

```{julia}
groups = ["vir","troch_LN"] # for purpose of calculating pairwise Fst and Fst_group (to determine SNPs)
plotGroups = ["vir","vir_S","nit", "lud_PK", "lud_KS", "lud_central", "lud_Sath", "lud_ML","troch_west","troch_LN"]
plotGroupColors = ["blue","turquoise1","grey","seagreen4","seagreen3","seagreen2","olivedrab3","olivedrab2","olivedrab1","yellow"]
numIndsToPlot = [10, 5, 2, 3, 5, 15, 3, 5, 10, 10] # maximum number of individuals to plot from each group
group1 = "vir"   # these groups will determine the color used in the graph
group2 = "troch_LN"
groupsToCompare = "vir_troch_LN" # "Fst_among"
Fst_cutoff = 0.9
missingFractionAllowed = 0.2  # only show SNPs with less than this fraction of missing data among individuals

# Calculate allele freqs and sample sizes (use column Fst_group)
freqs, sampleSizes = getFreqsAndSampleSizes(genosOnly_with_missing, ind_with_metadata_indFiltered.Fst_group, groups)
println("Calculated population allele frequencies and sample sizes")

# calculate Fst 
Fst, FstNumerator, FstDenominator, pairwiseNamesFst = getFst(freqs, sampleSizes, groups; among=true)  # set among to FALSE if no among Fst wanted (some things won't work without it) 
println("Calculated Fst values")

# limit the individuals to include in plot
# For this figure only, filter out individuals with lots of missing genotypes
numMissings_threshold = 800_000
selection = ind_with_metadata_indFiltered.numMissings .< numMissings_threshold
genosOnly_with_missing_selected = view(genosOnly_with_missing, selection, :)
ind_with_metadata_indFiltered_selected = view(ind_with_metadata_indFiltered, selection, :)
# now limit each group to specified numbers
genosOnly_included, ind_with_metadata_included = limitIndsToPlot(plotGroups, numIndsToPlot, genosOnly_with_missing_selected, ind_with_metadata_indFiltered_selected);

# choose the scaffold and region to show
chr = "gw26"
regionInfo = chooseChrRegion(pos_SNP_filtered, chr; positionMin=1, positionMax=scaffold_lengths[chr]) 

#### Now actually make the plot
plotInfo = plotGenotypeByIndividual(groupsToCompare, Fst_cutoff, missingFractionAllowed,
    regionInfo, pos_SNP_filtered, Fst, pairwiseNamesFst, 
    genosOnly_included, ind_with_metadata_included, freqs, plotGroups, plotGroupColors; plotTitle = "");
if false  # set to true to save plot
    save("Figure5_left_gw26GBIplotWest_from_Julia.png", plotInfo[1], px_per_unit = 2.0)
end 
```

Show another chromosome along west side of ring:

```{julia}
# choose the scaffold and region to show
chr = "gw28"
regionInfo = chooseChrRegion(pos_SNP_filtered, chr; positionMin=1, positionMax=scaffold_lengths[chr]) 

#### Now actually make the plot
plotInfo = plotGenotypeByIndividual(groupsToCompare, Fst_cutoff, missingFractionAllowed,
    regionInfo, pos_SNP_filtered, Fst, pairwiseNamesFst, 
    genosOnly_included, ind_with_metadata_included, freqs, plotGroups, plotGroupColors; plotTitle = "");
if false  # set to true to save plot
    save("Figure5_right_gw28GBIplotWest_from_Julia.png", plotInfo[1], px_per_unit = 2.0)
end 
```


#### Make a GBI plot to illustrate variation along east side of ring

```{julia}
groups = ["troch_LN","obs","plumb"] # for purpose of calculating pairwise Fst and Fst_group (to determine SNPs)
plotGroups = ["troch_LN","troch_EM","obs","plumb_BJ","plumb"]
plotGroupColors = ["yellow","gold","orange","pink","red"]
numIndsToPlot = [15, 15, 15, 15, 17] # maximum number of individuals to plot from each group
group1 = "troch_LN"   # these groups will determine the color used in the graph
group2 = "plumb"
groupsToCompare = "troch_LN_plumb" #"troch_LN_plumb" #"Fst_among"
Fst_cutoff = 0.9
missingFractionAllowed = 0.2  # only show SNPs with less than this fraction of missing data among individuals

# Calculate allele freqs and sample sizes (use column Fst_group)
freqs, sampleSizes = getFreqsAndSampleSizes(genosOnly_with_missing, ind_with_metadata_indFiltered.Fst_group, groups)
println("Calculated population allele frequencies and sample sizes")

# calculate Fst 
Fst, FstNumerator, FstDenominator, pairwiseNamesFst = getFst(freqs, sampleSizes, groups; among=true)  # set among to FALSE if no among Fst wanted (some things won't work without it) 
println("Calculated Fst values")

# limit the individuals to include in plot
# For this figure only, filter out individuals with lots of missing genotypes
numMissings_threshold = 800_000
selection = ind_with_metadata_indFiltered.numMissings .< numMissings_threshold
genosOnly_with_missing_selected = view(genosOnly_with_missing, selection, :)
ind_with_metadata_indFiltered_selected = view(ind_with_metadata_indFiltered, selection, :)

# now limit each group to specified numbers
genosOnly_included, ind_with_metadata_included = limitIndsToPlot(plotGroups, numIndsToPlot, genosOnly_with_missing_selected, ind_with_metadata_indFiltered_selected);

# choose the scaffold and region to show
chr = "gw28"
regionInfo = chooseChrRegion(pos_SNP_filtered, chr; positionMin=1, positionMax=scaffold_lengths[chr]) # this gets the maximum position for the chromosome

# need to remove two plumbeitarsus individuals that have introgression from viridanus, as that would otherwise be misleading in this figure since viridanus are not shown
selection = Not(ind_with_metadata_included.ind .âˆˆ Ref(["GW_Armando_plate1_JF09G01", "GW_Armando_plate1_JF24G02"]))
ind_with_metadata_included = ind_with_metadata_included[selection,:]
genosOnly_included = genosOnly_included[selection,:]

#### Now actually make the plot
plotInfo = plotGenotypeByIndividual(groupsToCompare, Fst_cutoff, missingFractionAllowed,
    regionInfo, pos_SNP_filtered, Fst, pairwiseNamesFst, 
    genosOnly_included, ind_with_metadata_included, freqs, plotGroups, plotGroupColors; plotTitle = "");
if false  # set to true to save plot
    save("Figure6_top_gw28GBIplotEast_from_Julia.png", plotInfo[1], px_per_unit = 2.0)
end 
```

######################

## Make GBI plots showing all individuals in the study

```{julia}
groups_to_plot_all = ["vir","vir_S","nit", "lud_PK", "lud_KS", "lud_central", "lud_Sath", "lud_ML","troch_west","troch_LN","troch_EM","obs","plumb_BJ","plumb","plumb_vir"]
group_colors_all = ["blue","turquoise1","grey","seagreen4","seagreen3","seagreen2","olivedrab3","olivedrab2","olivedrab1","yellow","gold","orange","pink","red","purple"];
```

This will use Fst among multiple groups to determine SNPs to plot.
For chr 28:

```{julia}
groups = ["vir","lud_PK","troch_LN","obs","plumb"] # for purpose of calculating pairwise Fst and Fst_group (to determine SNPs)   
plotGroups = groups_to_plot_all 
plotGroupColors = group_colors_all
group1 = "vir"   # these groups will determine the color used in the graph
group2 = "plumb"
groupsToCompare = ["vir_plumb", "vir_troch_LN", "troch_LN_plumb"]     # "Fst_among" #"vir_plumb" 
Fst_cutoff = 0.8
missingFractionAllowed = 0.2  # only show SNPs with less than this fraction of missing data among individuals

# Calculate allele freqs and sample sizes (use column Fst_group)
freqs, sampleSizes = getFreqsAndSampleSizes(genosOnly_with_missing, ind_with_metadata_indFiltered.Fst_group, groups)
println("Calculated population allele frequencies and sample sizes")

Fst, FstNumerator, FstDenominator, pairwiseNamesFst = getFst(freqs, sampleSizes, groups; among=true)  # set among to FALSE if no among Fst wanted (some things won't work without it) 
println("Calculated Fst values")

chr = "gw28"
regionInfo = chooseChrRegion(pos_SNP_filtered, chr; positionMin=1, positionMax=scaffold_lengths[chr]) # this gets the maximum position for the chromosome

plotInfo = plotGenotypeByIndividual(groupsToCompare, Fst_cutoff, 
    missingFractionAllowed, regionInfo,
    pos_SNP_filtered, Fst, pairwiseNamesFst, 
    genosOnly_with_missing, ind_with_metadata_indFiltered, freqs, 
    plotGroups, plotGroupColors;
    indFontSize=4, figureSize=(1200,1600),
    plotTitle = "");
# plotInfo contains a tuple with: (f, plottedGenotype, locations, plottedMetadata)
```

# Make list of scaffolds to plot according to above:

```{julia}
scaffolds_to_plot = "gw" .* string.(vcat(28:-1:17, 15:-1:1))
push!(scaffolds_to_plot, "gw1A", "gw4A")  # add two other scaffolds
```

Loop through each scaffold and produce GBI plot. (Making inactive because already saved figs and takes long.)

```julia
for i in 1:length(scaffolds_to_plot)
    chr = scaffolds_to_plot[i]
    regionInfo = chooseChrRegion(pos_SNP_filtered, chr; positionMin=1, positionMax=scaffold_lengths[chr]) # this gets the maximum position for the chromosome
    plotInfo = plotGenotypeByIndividual(groupsToCompare, Fst_cutoff, 
        missingFractionAllowed, regionInfo,
        pos_SNP_filtered, Fst, pairwiseNamesFst, 
        genosOnly_with_missing, ind_with_metadata_indFiltered, freqs, 
        plotGroups, plotGroupColors;
        indFontSize=4, figureSize=(1200,1600), plotTitle = "");
    println("Completed the figure for ", chr, ".")
    if true  # set to true to save plot
        filename = string("Figure_", chr, "_Fst3groups_GBI_allInds_from_Julia.png")
        save(filename, plotInfo[1], px_per_unit = 2.0)
        println("Saved ", filename)
    end 
end
```

#####################


## Estimate relationships of individuals using PCA

Our goal is to produce plots showing individuals in genotype space, using Principal Components Analysis. 

#### Impute and save genotypes for each scaffold

PCA requires imputation of missing genotypes. I did imputation for each scaffold above a certain size threshold. These are listed in `chromosomes_to_process` .

Imputation can take several minutes per scaffold, so I ran this imputation step separately from this Quarto notebook (otherwise render would take long) and saved the genotype data for each scaffold for loading in the next step. Below is the code I initially used for imputing, BUT IT USES THE SVD ALGORITHM AND I LATER DECIDED THAT KNN IS BETTER:

```julia
for i in eachindex(chromosomes_to_process)
    chrom = chromosomes_to_process[i]
    regionText = string("chr", chrom)
    loci_selection = (pos_SNP_filtered.chrom .== chrom)
    pos_SNP_filtered_region = pos_SNP_filtered[loci_selection,:]
    genosOnly_region_for_imputing = Matrix{Union{Missing, Float32}}(genosOnly_with_missing[:,loci_selection])
    @time imputed_genos = Impute.svd(genosOnly_region_for_imputing)
    filename = string(baseName, tagName, regionText, ".imputedMissing.jld2")
    jldsave(filename; imputed_genos, ind_with_metadata_indFiltered, pos_SNP_filtered_region)
    println(string("Chromosome ", chrom, ": Saved real and imputed genotypes for ", size(pos_SNP_filtered_region, 1)," SNPs and ", size(genosOnly_region_for_imputing, 1)," filtered individuals."))
end
```

Now we can cycle through a set of chromosomes and plot a PCA for each. We need to first specify some groups to include in the plot, and their colors:

```{julia}
groups_to_plot_PCA = ["vir","vir_S","nit", "lud_PK", "lud_KS", "lud_central", "lud_Sath", "lud_ML","troch_west","troch_LN","troch_EM","obs","plumb_BJ","plumb","plumb_vir"]
group_colors_PCA = ["blue","turquoise1","grey","seagreen4","seagreen3","seagreen2","olivedrab3","olivedrab2","olivedrab1","yellow","gold","orange","pink","red","purple"];
```

Now we'll actually do the PCA and make the plot for each scaffold. The code block below is what I initially used, based on the SVD method of imputing. I've now decided that KNN is better (see further below).

MAKING INACTIVE FOR NOW, BECAUSE MAKES A LOT OF PLOTS:

```julia
for i in eachindex(chromosomes_to_process)
    chrom = chromosomes_to_process[i]
    regionText = string("chr", chrom)
    filename = string(baseName, tagName, regionText, ".imputedMissing.jld2")
    imputed_genos = load(filename, "imputed_genos")
    ind_with_metadata_indFiltered = load(filename, "ind_with_metadata_indFiltered")
    pos_SNP_filtered_region = load(filename, "pos_SNP_filtered_region")
    println(string("Loaded ", filename))
    println(string(regionText, ": ", size(imputed_genos, 2), " SNPs from ", size(imputed_genos, 1), " individuals"))
    flipPC1 = true
    flipPC2 = true
    PCAmodel = plotPCA(imputed_genos, ind_with_metadata_indFiltered,
        groups_to_plot_PCA, group_colors_PCA;
        sampleSet="greenish warblers", regionText=regionText,
        flip1=flipPC1, flip2=flipPC2,
        showPlot=false)
    # add position of reference genome
    refGenomePCAposition = predict(PCAmodel.model, zeros(size(imputed_genos, 2)))
    flipPC1 && (refGenomePCAposition[1] *= -1)  # this flips PC1 if flipPC1 = true
    flipPC2 && (refGenomePCAposition[2] *= -1)  # same for PC2
    CairoMakie.scatter!(refGenomePCAposition[1], refGenomePCAposition[2], marker=:diamond, color="black", markersize=15, strokewidth=0.5)
    try
        display(PCAmodel.PCAfig)
    catch
        println("NOTICE: Figure for ", regionText, " could not be shown due to an unknown error.")
    end
end
```

#### Imputation using KNN

Troyanskaya _et al._ (2001) recommend imputation using K-nearest neighbors approach as being better than SVD, both of which are better than other methods for DNA genotyping. They also recommend using Euclidian distance. So I will try KNN with Euclidian distance, which like SVD is provided by Impute.jl. I am going with the default of setting `dims` to `:rows`, as that seems to run much faster and produces PCAs that make a lot of sense. I've already run this next code cell, which does the imputing and saves the imputed data matrix for each scaffold. This actually runs quite quickly--at most a couple minutes per scaffold. :)

```julia
for i in eachindex(chromosomes_to_process)
    chrom = chromosomes_to_process[i]
    regionText = string("chr", chrom)
    loci_selection = (pos_SNP_filtered.chrom .== chrom)
    pos_SNP_filtered_region = pos_SNP_filtered[loci_selection,:]
    genosOnly_region_for_imputing = Matrix{Union{Missing, Float32}}(genosOnly_with_missing[:,loci_selection])
    @time imputed_genos = Impute.knn(genosOnly_region_for_imputing; k=1, dims=:rows)
    filename = string(baseName, tagName, regionText, ".KNNimputedMissing.jld2")
    jldsave(filename; imputed_genos, ind_with_metadata_indFiltered, pos_SNP_filtered_region)
    println(string("Chromosome ", chrom, ": Saved real and imputed genotypes for ", size(pos_SNP_filtered_region, 1)," SNPs and ", size(genosOnly_region_for_imputing, 1)," filtered individuals."))
end
```

Now do the KNN PCA:

MAKING INACTIVE FOR NOW, BECAUSE MAKES A LOT OF PLOTS:

```julia
for i in eachindex(chromosomes_to_process)
    scaffold = chromosomes_to_process[i]
    regionText = string("chr", scaffold)
    filename = string(baseName, tagName, regionText, ".KNNimputedMissing.jld2")
    imputed_genos = load(filename, "imputed_genos")
    ind_with_metadata_indFiltered = load(filename, "ind_with_metadata_indFiltered")
    pos_SNP_filtered_region = load(filename, "pos_SNP_filtered_region")
    println(string("Loaded ",filename))
    println(string(regionText, ": ", size(imputed_genos,2), " SNPs from ", size(imputed_genos,1), " individuals"))
    flipPC1 = true
    flipPC2 = true
    PCAmodel = plotPCA(imputed_genos, ind_with_metadata_indFiltered, 
            groups_to_plot_PCA, group_colors_PCA; 
            sampleSet = "greenish warblers", regionText=regionText,
            flip1 = flipPC1, flip2 = flipPC2,
            lineOpacity = 0.7, fillOpacity = 0.6,
            symbolSize = 14, showTitle = true,
            xLabelText = string("Chromosome ", scaffold," PC1"), yLabelText = string("Chromosome ", scaffold," PC2"),
            showPlot = false)
    # add position of reference genome
    refGenomePCAposition = predict(PCAmodel.model, zeros(size(imputed_genos, 2)))
    flipPC1 && (refGenomePCAposition[1] *= -1)  # this flips PC1 if flipPC1 = true
    flipPC2 && (refGenomePCAposition[2] *= -1)  # same for PC2
    CairoMakie.scatter!(refGenomePCAposition[1], refGenomePCAposition[2], marker = :diamond, color="black", markersize=15, strokewidth=0.5)
    try
        display(PCAmodel.PCAfig)
    catch
        println("NOTICE: Figure for ", regionText, " could not be shown due to an unknown error.")
    end
end
```



####################################

## Produce Fst plot across genome

Adding this on Nov. 20th--requiring writing new Julia code in SNPlots.jl.

#### Calculate allele freqs and sample sizes (use column Fst_group)
```{julia}
groups = ["vir","troch_LN","plumb","plumb_vir"]
freqs, sampleSizes = getFreqsAndSampleSizes(genosOnly_ind_SNP_ind_filtered, ind_with_metadata_indFiltered.Fst_group, groups)
println("Calculated population allele frequencies and sample sizes")
```

#### calculate Fst for each SNP
```{julia}
Fst, FstNumerator, FstDenominator, pairwiseNamesFst = getFst(freqs, sampleSizes, groups; among=true)  # set among to FALSE if no among Fst wanted (some things won't work without it) 
println("Calculated Fst values")
```

#### specific scaffolds to consider in analyses (based on length cutoff)
```{julia}
scaffolds_to_consider = vec(["gw2",
                            "gw1",
                            "gw3",
                            "gwZ",
                            "gw1A",
                            "gw4",
                            "gw5",
                            "gw7",
                            "gw6",
                            "gw8",
                            "gw9",
                            "gw11",
                            "gw12",
                            "gw10",
                            "gw13",
                            "gw14",
                            "gw18",
                            "gw20",
                            "gw15",
                            "gw1B",
                            "gws100",
                            "gw17",
                            "gw19",
                            "gws101",
                            "gw4A",
                            "gw21",
                            "gw26",
                            "gws102",
                            "gw23",
                            "gw25",
                            "gws103",
                            "gw22",
                            "gws104",
                            "gw28",
                            "gw27",
                            "gw24",
                            "gws105",
                            "gws106",
                            "gws107",
                            "gws108",
                            "gws109",
                            "gws110",
                            "gws112"]);
```

# Make list of main scaffolds to include in Fst plot across genome:

```{julia}
scaffolds_for_Fst = "gw" .* string.(vcat(1, "1A", 2:4, "4A", 5:15, 17:28, "Z"))
```

vcat(1, "1A", 2:4, "4A", 5:15, 17:28)



#### calculate windowed Fst

This is calculated according to Weir&Cockerham1984 (with sample size and pop number correction), calculated as windowed numerator over windowed denominator, in whole windows starting on left side of chromosome.

```{julia}

windowSize = 500

# calculate windowed Fst across all scaffolds:

windowed_pos_all = DataFrame(chrom = String[], mean_position = Float64[])
windowed_Fst_all = Array{Float32, 2}(undef, size(FstNumerator, 1), 0)
for chrom in scaffolds_for_Fst
    regionText = string("chr", chrom)
    loci_selection = (pos_SNP_filtered.chrom .== chrom)
    pos_region = pos_SNP_filtered[loci_selection, :]
    FstNumerator_region = FstNumerator[:, loci_selection]
    FstDenominator_region = FstDenominator[:, loci_selection]
    windowedPos, windowedFst = getWindowedFst(FstNumerator_region, FstDenominator_region, pos_region, windowSize)
    windowed_pos_chrom = DataFrame(chrom = repeat([chrom], length(windowedPos)), mean_position = windowedPos)
    windowed_pos_all = vcat(windowed_pos_all, windowed_pos_chrom)
    windowed_Fst_all = hcat(windowed_Fst_all, windowedFst)
end

# The below is just a test plot, showing nothing useful really (as it overlaps all chromosomes onto one x axis):
#plot(windowed_pos_all.mean_position, windowed_Fst_all[1,:])
```

The above has produced windowed Fst values across the whole genome, for each population comparison. These are stored in `windowed_Fst_all` and the location info is stored in `windowed_pos_all`.

Now make a plot of windowed Fst across all scaffolds:

```{julia}

scaffolds_to_plot = scaffolds_for_Fst

groupsToPlotFst = ["vir_troch_LN", "troch_LN_plumb", "vir_plumb"]
groupColorsFst = ["green3", "orange", "purple"]
 
figHandle_GenomeFst3 = plotGenomeFst(scaffolds_to_plot, 
                                    windowed_Fst_all,
                                    pairwiseNamesFst,
                                    windowed_pos_all,
                                    groupsToPlotFst,
                                    groupColorsFst;
                                    lineTransparency = 0.8,
                                    fillTransparency = 0.2,
                                    figureSize=(1200, 1200))


```

Now do one with just the vir_plumb connection
```{julia}
groupsToPlotFst = ["vir_plumb"]
groupColorsFst = ["purple"]

figHandle_GenomeFst1 = plotGenomeFst(scaffolds_to_plot, 
                                    windowed_Fst_all,
                                    pairwiseNamesFst,
                                    windowed_pos_all,
                                    groupsToPlotFst,
                                    groupColorsFst;
                                    lineTransparency = 0.8,
                                    fillTransparency = 0.2,
                                    figureSize=(1200, 800))
```




###############

## Show windowed heterozygosity for individuals

```{julia}

# option to select a subset of individuals
filterGroups = false
#groupsToInclude = ["vir"]
#groupsToInclude = ["troch_LN"]
#numIndsToPlot = [1000]

# groupsToInclude = ["vir", "plumb", "plumb_vir"]
# numIndsToPlot = [1000, 1000, 1000]

# groupsToInclude = ["troch_LN","troch_EM","obs","plumb_BJ"]
# numIndsToPlot = [1000, 1000, 1000, 1000]

groupsToInclude = ["lud_PK", "lud_KS", "lud_central", "lud_Sath", "lud_ML","troch_west"]
numIndsToPlot = [1000, 1000, 1000, 1000, 1000, 1000]

if filterGroups
    genosOnly_included, ind_with_metadata_included = limitIndsToPlot(groupsToInclude, numIndsToPlot, genosOnly_with_missing, ind_with_metadata_indFiltered)
else
    genosOnly_included = genosOnly_with_missing
    ind_with_metadata_included = ind_with_metadata_indFiltered
end

chr = "gw15"
windowSize = 500
loci_selection = (pos_SNP_filtered.chrom .== chr)
pos_region = pos_SNP_filtered[loci_selection, :]
genotypes_region = genosOnly_included[:, loci_selection]

windowedPos, windowedIndHet = getWindowedIndHet(genotypes_region, pos_region, windowSize)

plotTitle = string("Windowed heterozygosity of ", size(windowedIndHet, 1), " individuals")
titleSize = 24
xLabelText = string("Location on scaffold ", chr)
yLabelText = "Heterozygosity"
labelSize = 24
f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title=plotTitle, titlesize=titleSize,
    xlabel=xLabelText, xlabelsize=labelSize,
    ylabel=yLabelText, ylabelsize=labelSize)
lines!(windowedPos, windowedIndHet[1, :])
for i in 2:size(windowedIndHet, 1)
    lines!(windowedPos, windowedIndHet[i, :])
end
meanPerWindow_windowedIndHet = sum(windowedIndHet, dims=1) ./ size(windowedIndHet, 1)
lines!(windowedPos, vec(meanPerWindow_windowedIndHet), linewidth=10, color=:red)
display(f)

windowedIndHet_standardized = standardizeIndHet(windowedIndHet)

plotTitle = string("Standardized heterozygosity of ", size(windowedIndHet, 1), " individuals")
titleSize = 24
xLabelText = string("Location on scaffold ", chr)
yLabelText = "Standardized heterozygosity"
labelSize = 24
g = CairoMakie.Figure()
ax = Axis(g[1, 1],
    title=plotTitle, titlesize=titleSize,
    xlabel=xLabelText, xlabelsize=labelSize,
    ylabel=yLabelText, ylabelsize=labelSize)
for i in 1:size(windowedIndHet_standardized, 1)
    lines!(windowedPos, windowedIndHet_standardized[i, :])
end
#lines!(windowedPos, windowedIndHet[21,:], linewidth = 10, color = :red)
display(g)

# Now graph the variance in standardized heterozygosity

varWindowedIndHet = getVarWindowedIndHet(windowedIndHet_standardized)

plotTitle = string("Variance in standardized het. among ", size(windowedIndHet, 1), " individuals")
titleSize = 18
xLabelText = string("Location on scaffold ", chr)
yLabelText = "Heterozygosity variance (standardized)"
labelSize = 18
h = CairoMakie.Figure()
ax = Axis(h[1, 1],
    title=plotTitle, titlesize=titleSize,
    xlabel=xLabelText, xlabelsize=labelSize,
    ylabel=yLabelText, ylabelsize=labelSize)
lines!(windowedPos, varWindowedIndHet)
display(h)

```


# Make heterozygosity variance plot for whole genome:

```{julia}

# option to select a subset of individuals
filterGroups = false
# groupsToInclude = ["vir", "plumb", "plumb_vir"]
# numIndsToPlot = [1000, 1000, 1000]

# groupsToInclude = ["lud_PK", "lud_KS", "lud_central", "lud_Sath", "lud_ML","troch_west","troch_LN"]
# numIndsToPlot = [1000, 1000, 1000, 1000, 1000, 1000, 1000]

# groupsToInclude = ["troch_LN","troch_EM","obs","plumb_BJ"]
# numIndsToPlot = [1000, 1000, 1000, 1000]

groupsToInclude = ["vir"]
#groupsToInclude = ["troch_LN"]
numIndsToPlot = [1000]

if filterGroups
    genosOnly_included, ind_with_metadata_included = limitIndsToPlot(groupsToInclude, numIndsToPlot, genosOnly_with_missing, ind_with_metadata_indFiltered)
else
    genosOnly_included = genosOnly_with_missing
    ind_with_metadata_included = ind_with_metadata_indFiltered
end

#scaffolds_for_HetVariance = ["gw26", "gw28"]
scaffolds_for_HetVariance = scaffolds_for_Fst
#initialize data structures
windowed_pos_all = DataFrame(chrom = String[], mean_position = Float64[], first_position = Int[], last_position = Int[])
windowed_HetVariance_all = Vector{Float32}(undef, 0)
for chrom in scaffolds_for_HetVariance
    regionText = string("chr", chrom)
    loci_selection = (pos_SNP_filtered.chrom .== chrom)
    pos_region = pos_SNP_filtered[loci_selection, :]
    genotypes_region = genosOnly_included[:, loci_selection]
    windowedPos, windowedIndHet = getWindowedIndHet(genotypes_region, pos_region, windowSize)
    windowBoundaries = getWindowBoundaries(pos_region.position, windowSize)
    windowedIndHet_standardized = standardizeIndHet(windowedIndHet)
    windowed_HetVariance_scaffold = getVarWindowedIndHet(windowedIndHet_standardized)
    windowed_pos_chrom = DataFrame(chrom = repeat([chrom], length(windowedPos)), mean_position = windowedPos, first_position = windowBoundaries[:,1], last_position = windowBoundaries[:,2])
    windowed_pos_all = vcat(windowed_pos_all, windowed_pos_chrom)
    windowed_HetVariance_all = [windowed_HetVariance_all; windowed_HetVariance_scaffold]
end

# Quick test plot (overlapping all chromosomes, so not good)
plot(windowed_pos_all.mean_position, windowed_HetVariance_all)
```

# Identify "haploblock regions" as those that have high HetVar

```{julia}
threshold_HetVar = 0.4
selection = windowed_HetVariance_all .>= threshold_HetVar
windowed_pos_all.high_HetVar = selection # adds true/false column to dataframe indicating high HetVar windows

# Make list of contiguous high HetVar region:

highHetVarRegions = DataFrame(regionChrom = String[], regionStart = Int[], regionEnd = Int[])
i = 1
lastWindow = nrow(windowed_pos_all)
while i <= lastWindow # eachindex(windowed_pos_all[:,1])
    if windowed_pos_all.high_HetVar[i] == true
        regionChrom = windowed_pos_all.chrom[i]
        regionStart = windowed_pos_all.first_position[i]
        regionEnd = windowed_pos_all.last_position[i]
        # check whether contiguous with next
        next = 1
        while i + next <= lastWindow && windowed_pos_all.chrom[i + next] == regionChrom
            if windowed_pos_all.high_HetVar[i + next] == true
                regionEnd = windowed_pos_all.last_position[i + next]
                next += 1
            else
                break
            end
        end
        highHetVarRegions = push!(highHetVarRegions, [regionChrom, regionStart, regionEnd])
        i = i + next + 1
    else
        i = i + 1
    end 
    i
end
```


# Plot "haploblock regions" for whole genome

```{julia}

function plotGenomeHetVariance(scaffolds_to_plot, 
                                windowed_HetVariance_all,
                                windowed_pos_all;
                                fillColor = "purple",
                                lineTransparency = 0.8,
                                fillTransparency = 0.2,
                                figureSize = (1200, 1200),
                                plotRegions = false,
                                regionsToPlot = [])
    
    # get sizes of chromosomes (note this actually isn't the true length, just the mean position of the rightmost window):
    scaffold_lengths = repeat([-1], length(scaffolds_to_plot))	# vector of Int64
    for i in 1:length(scaffolds_to_plot)
        selection = windowed_pos_all.chrom .== scaffolds_to_plot[i]
        if sum(selection) == 0
            scaffold_lengths[i] = 0
        else
            scaffold_lengths[i] = round(Int, maximum(windowed_pos_all.mean_position[selection]))
        end
    end

    # my plan is to use the layout feature of Makie to make one axis per row, and then plot
    # multiple scaffolds to each row

    scaffoldPlottedAlready = falses(length(scaffolds_to_plot))
    bpPerRow = 200_000_000
    bpGapBetweenScaffolds = 10_000_000
    scaffoldInRow = Vector{Vector{String}}() # declare a vector of vectors to store the chromosome names per row
    scaffoldBpStartInRow = Vector{Vector{Int}}()
    row = 1

    while sum(scaffoldPlottedAlready .== false) > 0  # repeat until all chr have a row to be plotted in
        bpStart = 0
        remainingRowLength = bpPerRow
        push!(scaffoldInRow, []) # initialize an empty vector for the next row
        push!(scaffoldBpStartInRow, []) # initialize an empty vector for the next row
        placeInRow = 1
        # look through chromosomes and find some to go in this row
        for i in 1:length(scaffolds_to_plot)
            # if not plotted and short enough, add to row:
            if scaffoldPlottedAlready[i] .== false .&& scaffold_lengths[i] .<= remainingRowLength
                push!(scaffoldInRow[row], scaffolds_to_plot[i])
                push!(scaffoldBpStartInRow[row], bpStart)
                remainingRowLength = remainingRowLength - scaffold_lengths[i] - bpGapBetweenScaffolds
                scaffoldPlottedAlready[i] = true
                placeInRow += 1
                bpStart = bpStart + scaffold_lengths[i] + bpGapBetweenScaffolds
            end	
        end
        row += 1
    end
    println(scaffoldInRow)

    # the above works. I have the scaffolds arranged for plotting.

    # Plot in the order defined above
    f = CairoMakie.Figure(size=figureSize)
    numRows = length(scaffoldInRow)
    # make one axis object per row:
    axs = [Axis(f[i, 1], limits=(0, bpPerRow,
            0, 2.3), ylabel = "HetVar") for i in 1:numRows]
    for i in 1:numRows
        hidexdecorations!(axs[i]) #hide background lattice and axis labels
        hidespines!(axs[i], :t, :r, :b) # hide box around plot
    end

    for rowNum in 1:numRows
        numScaffoldsInRow = length(scaffoldInRow[rowNum])
        nextPlotShiftBP = 0
        for orderNum in 1:numScaffoldsInRow 
            scaffoldName = scaffoldInRow[rowNum][orderNum]
            plotBpLength = scaffold_lengths[findfirst(scaffolds_to_plot .== scaffoldName)]
            # select one scaffold from the whole genome:
            selection = windowed_pos_all.chrom .== scaffoldName 
            windowed_pos_selected = view(windowed_pos_all.mean_position, selection)
            windowed_HetVariance_selected = view(windowed_HetVariance_all, selection)
            if length(windowed_pos_selected) > 0  # only plot if there is data for that scaffold        
                text!(axs[rowNum], scaffoldBpStartInRow[rowNum][orderNum] + 0.005bpPerRow, 2.1; text=scaffoldName, align=(:left, :center), fontsize=20)
                xx = vcat(first(windowed_pos_selected), windowed_pos_selected, last(windowed_pos_selected)) .+ scaffoldBpStartInRow[rowNum][orderNum]
                yy = vcat(0, windowed_HetVariance_selected, 0)
                poly!(axs[rowNum], Point2f.(xx, yy), color = (fillColor, fillTransparency), strokecolor = (fillColor, lineTransparency), strokewidth = 1)
                # if indicating regions (e.g. that have high HetVar)
                if plotRegions
                    regionsToPlot_thisScaffold = regionsToPlot[regionsToPlot.regionChrom .== scaffoldName, :]
                    for i in eachindex(regionsToPlot_thisScaffold.regionStart)
                        xValues = [regionsToPlot_thisScaffold.regionStart[i], regionsToPlot_thisScaffold.regionEnd[i]] .+ scaffoldBpStartInRow[rowNum][orderNum]
                        yValues = [0.05, 0.05]
                        lines!(axs[rowNum], xValues, yValues, color="red", linewidth=10)
                    end
                end
            end
        end
    end
    display(f)
end


plotGenomeHetVariance(scaffolds_to_plot, 
                        windowed_HetVariance_all,
                        windowed_pos_all;
                        fillColor = "purple",
                        lineTransparency = 0.8,
                        fillTransparency = 0.2,
                        figureSize=(1200, 1200),
                        plotRegions = true,
                        regionsToPlot = highHetVarRegions)

```

# Choose low-het individuals in a high HetVar region

Now that we have high HetVar regions indicated, we can automate the choosing of essential homozygous individuals in those regions. Here I will do this for chr15:

```{julia}
# choose scaffold
chr = "gw15"

# remake the windowedIndHet_standardized (done above in a different cell)
windowSize = 500
loci_selection = (pos_SNP_filtered.chrom .== chr)
pos_region = pos_SNP_filtered[loci_selection, :]
genotypes_region = genosOnly_included[:, loci_selection]

windowedPos, windowedIndHet = getWindowedIndHet(genotypes_region, pos_region, windowSize)

windowedIndHet_standardized = standardizeIndHet(windowedIndHet)

# look up the boundaries of the high HetVar region:

selection = highHetVarRegions.regionChrom .== chr
if sum(selection) == 1
    "Good news: 1 region on that scaffold"
    positionMin = highHetVarRegions.regionStart[selection][1]
    positionMax = highHetVarRegions.regionEnd[selection][1]
    regionText = string("chr ", chr, " ",positionMin," to ",positionMax)
elseif sum(selection) > 1
    "More than 1 region on that scaffold"
elseif sum(selection) == 0
    "No high HetVar regions on that scaffold"
end

# choose just the windows that are in the high HetVar region:

selection = (positionMin .< windowedPos .< positionMax)
windowedIndHet_standardized_region = windowedIndHet_standardized[:,selection]

# average across windows for each individual:

meanAcrossRegion_IndHet_standardized = mean.(eachrow(windowedIndHet_standardized_region)) 

plot(meanAcrossRegion_IndHet_standardized)

ind_with_metadata_included.chr15RegIndHetStan = meanAcrossRegion_IndHet_standardized

# check whether missing data related to heterozygosity (good news: not really)
plot(ind_with_metadata_included.numMissings, ind_with_metadata_included.chr15RegIndHetStan)

# to inspect data, sort by chr15RegIndHetStan :

ind_with_metadata_included_sortedbyHetVar = sort(ind_with_metadata_included, [:chr15RegIndHetStan])

# for demonstration haplotypes, choose individuals with numMissings < 100_000
# and chr15RegIndHetStan < 0.5:

selection = (ind_with_metadata_included.numMissings .< 200_000) .& (ind_with_metadata_included.chr15RegIndHetStan .< 0.75)

ind_with_metadata_haplotypeCandidates = ind_with_metadata_included[selection, :]

# But the above cuts out the obscuratus and nitidus individuals (which have about 700k missing genome-wide at least in early filtering calculations)
# So don't worry about missings for now--just sort and choose low ones for each haplogroup:

# GW_Armando_plate2_TTGW73  #lud_Sath

# GW_Armando_plate2_LN2 #troch_LN

# GW_Armando_plate2_TTGW-15-04 #lud_Sural

# GW_Armando_plate1_JG02G02 #plumb

# GW_Armando_plate2_JE31G01 #vir

# GW_Armando_plate1_RF20G01 #plumb_BJ

# GW_Lane5_TU1 #nit

indsToChoose = ["GW_Armando_plate2_TTGW73",
                "GW_Armando_plate2_LN2",
                "GW_Armando_plate2_TTGW-15-04",
                "GW_Armando_plate1_JG02G02",
                "GW_Armando_plate2_JE31G01",
                "GW_Armando_plate1_RF20G01",
                "GW_Lane5_TU1"]

selection = map(in(indsToChoose), ind_with_metadata_included.ind)
filtered_in = ind_with_metadata_included.ind[selection]
ind_with_metadata_chosenInds = ind_with_metadata_included[selection, :]
geno_indFiltered = view(genotypes_region, selection, :)
println("Specific individuals chosen as requested: ")
display(filtered_in)

# choose the loci in the high HetVar region:

selection = (positionMin .< pos_region.position .< positionMax)

geno_indFiltered_highHetVarRegion = geno_indFiltered[:, selection]

# put in plot order:

indexOrder = sortperm(ind_with_metadata_chosenInds.plot_order)
geno_indFiltered_highHetVarRegion_ordered = geno_indFiltered_highHetVarRegion[indexOrder, :]
ind_with_metadata_chosenInds_ordered = ind_with_metadata_chosenInds[indexOrder, :]

# ABOVE HAVE GENOTYPES FOR JUST THESE INDIVIDUALS IN JUST THE HIGH HETVAR REGION ON THE ONE CHR. NEXT DO GENETIC DISTANCE BETWEEN ALL PAIRS OF INDIVIDUALS FOR THIS REGION. 
# count mismatches and divide by total number of sites.
# mismatches of genotype 0 to genotype 2 count as 1 mismatch.
# genotype 0 or 2 to genotype 1 (het) counts as 0.5 mismatch.
# genotype 1 to genotype 1 counts as 0.5 mismatch

numInds = nrow(ind_with_metadata_chosenInds_ordered)
distanceMatrix = Matrix{Float64}(undef, numInds, numInds)
for i in 1:numInds
    for j in 1:numInds
        firstGeno = geno_indFiltered_highHetVarRegion_ordered[i,:]
        secondGeno = geno_indFiltered_highHetVarRegion_ordered[j,:]
        fullMismatches = sum((firstGeno .== 0 .&& secondGeno .== 2) .||
                            (firstGeno .== 2 .&& secondGeno .== 0))
        partialMismatches = sum((firstGeno .== 0 .&& secondGeno .== 1) .|| 
                                (firstGeno .== 1 .&& secondGeno .== 0) .|| 
                                (firstGeno .== 2 .&& secondGeno .== 1) .|| 
                                (firstGeno .== 1 .&& secondGeno .== 2))
        bothHet = sum(firstGeno .== 1 .&& secondGeno .== 1)
        distanceMatrix[i,j] = (fullMismatches + 0.5partialMismatches + 0.5bothHet) / size(geno_indFiltered_highHetVarRegion_ordered, 2)
    end
end





```






# Make GBI plots showing just west individuals:

```{julia}
groups = ["vir","lud_PK","troch_LN"] # for purpose of calculating pairwise Fst and Fst_group (to determine SNPs)   
plotGroups = ["vir", "vir_misID", "vir_S", "nit", "lud_PK", "lud_KS", "lud_central", "lud_Sath", "lud_ML", "troch_west", "troch_LN"] # west GW individuals
plotGroupColors = ["blue", "blue", "turquoise1", "grey", "seagreen4", "seagreen3", "seagreen2", "olivedrab3", "olivedrab2", "olivedrab1", "yellow"]
group1 = "vir"   # these groups will determine the color used in the graph
group2 = "troch_LN"
groupsToCompare = "Fst_among" #"vir_plumb" 
Fst_cutoff = 0.8
missingFractionAllowed = 0.2  # only show SNPs with less than this fraction of missing data among individuals

# Calculate allele freqs and sample sizes (use column Fst_group)
freqs, sampleSizes = getFreqsAndSampleSizes(genosOnly_with_missing, ind_with_metadata_indFiltered.Fst_group, groups)
println("Calculated population allele frequencies and sample sizes")

Fst, FstNumerator, FstDenominator, pairwiseNamesFst = getFst(freqs, sampleSizes, groups; among=true)  # set among to FALSE if no among Fst wanted (some things won't work without it) 
println("Calculated Fst values")

scaffolds_to_plot = ["gw1"]

for i in 1:length(scaffolds_to_plot)
    chr = scaffolds_to_plot[i]
    regionInfo = chooseChrRegion(pos_SNP_filtered, chr; positionMin=1, positionMax=scaffold_lengths[chr]) # this gets the maximum position for the chromosome
    plotInfo = plotGenotypeByIndividual(groupsToCompare, Fst_cutoff, 
        missingFractionAllowed, regionInfo,
        pos_SNP_filtered, Fst, pairwiseNamesFst, 
        genosOnly_with_missing, ind_with_metadata_indFiltered, freqs, 
        plotGroups, plotGroupColors;
        indFontSize=4, figureSize=(1200,1600))
    println("Completed the figure for ", chr, ".")
end

#for chr in scaffolds_to_plot
#    println(chr)
#end
# plotInfo contains a tuple with: (f, plottedGenotype, locations, plottedMetadata)
```

# Make GBI plots showing just east individuals:

```{julia}
groups = ["troch_LN","obs","plumb"] # for purpose of calculating pairwise Fst and Fst_group (to determine SNPs)   
plotGroups = ["troch_LN", "troch_EM", "obs", "plumb_BJ", "plumb"] # east GW individuals
plotGroupColors = ["yellow", "gold", "orange", "pink", "red"]
group1 = "troch_LN"   # these groups will determine the color used in the graph
group2 = "plumb"
groupsToCompare = "Fst_among" #"vir_plumb" 
Fst_cutoff = 0.6
missingFractionAllowed = 0.2  # only show SNPs with less than this fraction of missing data among individuals

# Calculate allele freqs and sample sizes (use column Fst_group)
freqs, sampleSizes = getFreqsAndSampleSizes(genosOnly_with_missing, ind_with_metadata_indFiltered.Fst_group, groups)
println("Calculated population allele frequencies and sample sizes")

Fst, FstNumerator, FstDenominator, pairwiseNamesFst = getFst(freqs, sampleSizes, groups; among=true)  # set among to FALSE if no among Fst wanted (some things won't work without it) 
println("Calculated Fst values")

for i in 1:length(scaffolds_to_plot)
    chr = scaffolds_to_plot[i]
    regionInfo = chooseChrRegion(pos_SNP_filtered, chr; positionMin=1, positionMax=scaffold_lengths[chr]) # this gets the maximum position for the chromosome
    plotInfo = plotGenotypeByIndividual(groupsToCompare, Fst_cutoff, 
        missingFractionAllowed, regionInfo,
        pos_SNP_filtered, Fst, pairwiseNamesFst, 
        genosOnly_with_missing, ind_with_metadata_indFiltered, freqs, 
        plotGroups, plotGroupColors;
        indFontSize=4, figureSize=(1200,1600))
    println("Completed the figure for ", chr, ".")
end
# plotInfo contains a tuple with: (f, plottedGenotype, locations, plottedMetadata)
```



 