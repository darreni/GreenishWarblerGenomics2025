---
title: "Greenish Warbler heterozygosity variance analysis"
author: "Darren Irwin"
date: "6/11/2024"
execute:
  echo: true
format:
  html:
    code-fold: false
  pdf:
    keep-tex: false
    monofont: "JuliaMono"
jupyter: julia-1.10
---

This script depends on `GreenishWarblerGenomics2023.qmd` and `GW_Zchromosome_analysis.qmd`

## Load the filtered dataset

This dataset was produced through filtering in GreenishWarblerGenomics2023.qmd

```{julia}
filename = string(baseName, tagName, ".ind_SNP_ind_filtered.jld2")
genosOnly = load(filename, "genosOnly_ind_SNP_ind_filtered")
ind_with_metadata_indFiltered = load(filename, "ind_with_metadata_indFiltered")
pos_SNP_filtered = load(filename, "pos_SNP_filtered")
println("Loaded the filtered data.")
```

## Replace the Z chromosome SNPs with the filtered Z chromosome SNPs

```{julia}
# remove the Z SNPs from the big dataset loaded above:
selection = (pos_SNP_filtered.chrom .!= "gwZ")
pos_SNP_filtered = pos_SNP_filtered[selection, :]
genosOnly = genosOnly[:,selection]

# load and add the Z filtered SNPs:
filename = string(baseName, tagName, "chrgwZ_cleaned.notImputed.jld2")
genosOnly_chrgwZ_cleaned = load(filename, "genotypes_gwZ_SNPfiltered")
ind_with_metadata_indFiltered_chrgwZ_cleaned = load(filename, "ind_with_metadata_indFiltered")
pos_SNP_filtered_chrgwZ_cleaned = load(filename, "pos_SNP_filtered_region")

if ind_with_metadata_indFiltered.ind != ind_with_metadata_indFiltered_chrgwZ_cleaned.ind
    println("Warning: the list of individuals in the big file and Z file are not completely identical.")
end

pos_SNP_filtered = vcat(pos_SNP_filtered, pos_SNP_filtered_chrgwZ_cleaned)
genosOnly = hcat(genosOnly, genosOnly_chrgwZ_cleaned)

println("Replaced the Z chromosome data with the filtered Z data.")

```




## Prepare data for Genotype-by-individual plots and PCA

For missing genotypes, change our code of `-1` to `missing`:

```{julia}
genosOnly_with_missing = Matrix{Union{Missing, Int16}}(genosOnly)
genosOnly_with_missing = replace(genosOnly_with_missing, -1 => missing)
#genosOnly_with_missing[genosOnly_with_missing .== -1] .= missing;
```

# Make list of scaffolds to plot:

```{julia}
scaffolds_to_plot = "gw" .* string.(vcat(1, "1A", 2:4, "4A", 5:15, 17:28, "Z"))
```

# Choose groups and colors

```{julia}
groups_to_plot_PCA = ["vir","vir_S","nit", "lud_PK", "lud_KS", "lud_central", "lud_Sath", "lud_ML","troch_west","troch_LN","troch_EM","obs","plumb_BJ","plumb","plumb_vir"]
group_colors_PCA = ["blue","turquoise1","grey","seagreen4","seagreen3","seagreen2","olivedrab3","olivedrab2","olivedrab1","yellow","gold","orange","pink","red","purple"];
```

###############

## Show windowed heterozygosity for individuals

```{julia}

# option to select a subset of individuals
filterGroups = false
#groupsToInclude = ["vir"]
#groupsToInclude = ["troch_LN"]
#numIndsToPlot = [1000]

# groupsToInclude = ["vir", "plumb", "plumb_vir"]
# numIndsToPlot = [1000, 1000, 1000]

# groupsToInclude = ["troch_LN","troch_EM","obs","plumb_BJ"]
# numIndsToPlot = [1000, 1000, 1000, 1000]

groupsToInclude = ["lud_PK", "lud_KS", "lud_central", "lud_Sath", "lud_ML","troch_west"]
numIndsToPlot = [1000, 1000, 1000, 1000, 1000, 1000]

if filterGroups
    genosOnly_included, ind_with_metadata_included = limitIndsToPlot(groupsToInclude, numIndsToPlot, genosOnly_with_missing, ind_with_metadata_indFiltered)
else
    genosOnly_included = genosOnly_with_missing
    ind_with_metadata_included = ind_with_metadata_indFiltered
end

chr = "gw15"
windowSize = 500
loci_selection = (pos_SNP_filtered.chrom .== chr)
pos_region = pos_SNP_filtered[loci_selection, :]
genotypes_region = genosOnly_included[:, loci_selection]

windowedPos, windowedIndHet = getWindowedIndHet(genotypes_region, pos_region, windowSize)

plotTitle = string("Windowed heterozygosity of ", size(windowedIndHet, 1), " individuals")
titleSize = 24
xLabelText = string("Location on scaffold ", chr)
yLabelText = "Heterozygosity"
labelSize = 24
f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title=plotTitle, titlesize=titleSize,
    xlabel=xLabelText, xlabelsize=labelSize,
    ylabel=yLabelText, ylabelsize=labelSize)
lines!(windowedPos, windowedIndHet[1, :])
for i in 2:size(windowedIndHet, 1)
    lines!(windowedPos, windowedIndHet[i, :])
end
meanPerWindow_windowedIndHet = sum(windowedIndHet, dims=1) ./ size(windowedIndHet, 1)
lines!(windowedPos, vec(meanPerWindow_windowedIndHet), linewidth=10, color=:red)
display(f)

windowedIndHet_standardized = standardizeIndHet(windowedIndHet)

plotTitle = string("Standardized heterozygosity of ", size(windowedIndHet, 1), " individuals")
titleSize = 24
xLabelText = string("Location on scaffold ", chr)
yLabelText = "Standardized heterozygosity"
labelSize = 24
g = CairoMakie.Figure()
ax = Axis(g[1, 1],
    title=plotTitle, titlesize=titleSize,
    xlabel=xLabelText, xlabelsize=labelSize,
    ylabel=yLabelText, ylabelsize=labelSize)
for i in 1:size(windowedIndHet_standardized, 1)
    lines!(windowedPos, windowedIndHet_standardized[i, :])
end
#lines!(windowedPos, windowedIndHet[21,:], linewidth = 10, color = :red)
display(g)

# Now graph the variance in standardized heterozygosity

varWindowedIndHet = getVarWindowedIndHet(windowedIndHet_standardized)

plotTitle = string("Variance in standardized het. among ", size(windowedIndHet, 1), " individuals")
titleSize = 18
xLabelText = string("Location on scaffold ", chr)
yLabelText = "Heterozygosity variance (standardized)"
labelSize = 18
h = CairoMakie.Figure()
ax = Axis(h[1, 1],
    title=plotTitle, titlesize=titleSize,
    xlabel=xLabelText, xlabelsize=labelSize,
    ylabel=yLabelText, ylabelsize=labelSize)
lines!(windowedPos, varWindowedIndHet)
display(h)

```


# Make heterozygosity variance plot for whole genome:

```{julia}

# option to select a subset of individuals
filterGroups = false
# groupsToInclude = ["vir", "plumb", "plumb_vir"]
# numIndsToPlot = [1000, 1000, 1000]

# groupsToInclude = ["lud_PK", "lud_KS", "lud_central", "lud_Sath", "lud_ML","troch_west","troch_LN"]
# numIndsToPlot = [1000, 1000, 1000, 1000, 1000, 1000, 1000]

# groupsToInclude = ["troch_LN","troch_EM","obs","plumb_BJ"]
# numIndsToPlot = [1000, 1000, 1000, 1000]

groupsToInclude = ["vir"]
#groupsToInclude = ["troch_LN"]
numIndsToPlot = [1000]

if filterGroups
    genosOnly_included, ind_with_metadata_included = limitIndsToPlot(groupsToInclude, numIndsToPlot, genosOnly_with_missing, ind_with_metadata_indFiltered)
else
    genosOnly_included = genosOnly_with_missing
    ind_with_metadata_included = ind_with_metadata_indFiltered
end

#scaffolds_for_HetVariance = ["gw26", "gw28"]
scaffolds_for_HetVariance = scaffolds_to_plot
#initialize data structures
windowed_pos_all = DataFrame(chrom = String[], mean_position = Float64[], first_position = Int[], last_position = Int[])
windowed_HetVariance_all = Vector{Float32}(undef, 0)
for chrom in scaffolds_for_HetVariance
    regionText = string("chr", chrom)
    loci_selection = (pos_SNP_filtered.chrom .== chrom)
    pos_region = pos_SNP_filtered[loci_selection, :]
    genotypes_region = genosOnly_included[:, loci_selection]
    if chrom == "gwZ" #include only males (because females have only one Z)
        genotypes_region_males = genotypes_region[ind_with_metadata_indFiltered_chrgwZ_cleaned.sex .== "M", :]
        windowedPos, windowedIndHet = getWindowedIndHet(genotypes_region_males, pos_region, windowSize)
    else # for all other chromosomes, include all individuals
        windowedPos, windowedIndHet = getWindowedIndHet(genotypes_region, pos_region, windowSize)
    end
    windowBoundaries = getWindowBoundaries(pos_region.position, windowSize)
    windowedIndHet_standardized = standardizeIndHet(windowedIndHet)
    windowed_HetVariance_scaffold = getVarWindowedIndHet(windowedIndHet_standardized)
    windowed_pos_chrom = DataFrame(chrom = repeat([chrom], length(windowedPos)), mean_position = windowedPos, first_position = windowBoundaries[:,1], last_position = windowBoundaries[:,2])
    windowed_pos_all = vcat(windowed_pos_all, windowed_pos_chrom)
    windowed_HetVariance_all = [windowed_HetVariance_all; windowed_HetVariance_scaffold]
end

# Quick test plot (overlapping all chromosomes, so not good)
plot(windowed_pos_all.mean_position, windowed_HetVariance_all)
```

# Identify "haploblock regions" as those that have high HetVar

```{julia}
threshold_HetVar = 0.4
selection = windowed_HetVariance_all .>= threshold_HetVar
windowed_pos_all.high_HetVar = selection # adds true/false column to dataframe indicating high HetVar windows

# Make list of contiguous high HetVar region:

highHetVarRegions = DataFrame(regionChrom = String[], regionStart = Int[], regionEnd = Int[])
i = 1
lastWindow = nrow(windowed_pos_all)
while i <= lastWindow # eachindex(windowed_pos_all[:,1])
    if windowed_pos_all.high_HetVar[i] == true
        regionChrom = windowed_pos_all.chrom[i]
        regionStart = windowed_pos_all.first_position[i]
        regionEnd = windowed_pos_all.last_position[i]
        # check whether contiguous with next
        next = 1
        while i + next <= lastWindow && windowed_pos_all.chrom[i + next] == regionChrom
            if windowed_pos_all.high_HetVar[i + next] == true
                regionEnd = windowed_pos_all.last_position[i + next]
                next += 1
            else
                break
            end
        end
        highHetVarRegions = push!(highHetVarRegions, [regionChrom, regionStart, regionEnd])
        i = i + next + 1
    else
        i = i + 1
    end 
    i
end
```


# Plot "haploblock regions" for whole genome

```{julia}

function plotGenomeHetVariance(scaffolds_to_plot, 
                                windowed_HetVariance_all,
                                windowed_pos_all;
                                fillColor = "purple",
                                lineTransparency = 0.8,
                                fillTransparency = 0.2,
                                figureSize = (1200, 1200),
                                plotRegions = false,
                                regionsToPlot = [])
    
    # get sizes of chromosomes (note this actually isn't the true length, just the mean position of the rightmost window):
    scaffold_lengths = repeat([-1], length(scaffolds_to_plot))	# vector of Int64
    for i in 1:length(scaffolds_to_plot)
        selection = windowed_pos_all.chrom .== scaffolds_to_plot[i]
        if sum(selection) == 0
            scaffold_lengths[i] = 0
        else
            scaffold_lengths[i] = round(Int, maximum(windowed_pos_all.mean_position[selection]))
        end
    end

    # my plan is to use the layout feature of Makie to make one axis per row, and then plot
    # multiple scaffolds to each row

    scaffoldPlottedAlready = falses(length(scaffolds_to_plot))
    bpPerRow = 200_000_000
    bpGapBetweenScaffolds = 10_000_000
    scaffoldInRow = Vector{Vector{String}}() # declare a vector of vectors to store the chromosome names per row
    scaffoldBpStartInRow = Vector{Vector{Int}}()
    row = 1

    while sum(scaffoldPlottedAlready .== false) > 0  # repeat until all chr have a row to be plotted in
        bpStart = 0
        remainingRowLength = bpPerRow
        push!(scaffoldInRow, []) # initialize an empty vector for the next row
        push!(scaffoldBpStartInRow, []) # initialize an empty vector for the next row
        placeInRow = 1
        # look through chromosomes and find some to go in this row
        for i in 1:length(scaffolds_to_plot)
            # if not plotted and short enough, add to row:
            if scaffoldPlottedAlready[i] .== false .&& scaffold_lengths[i] .<= remainingRowLength
                push!(scaffoldInRow[row], scaffolds_to_plot[i])
                push!(scaffoldBpStartInRow[row], bpStart)
                remainingRowLength = remainingRowLength - scaffold_lengths[i] - bpGapBetweenScaffolds
                scaffoldPlottedAlready[i] = true
                placeInRow += 1
                bpStart = bpStart + scaffold_lengths[i] + bpGapBetweenScaffolds
            end	
        end
        row += 1
    end
    println(scaffoldInRow)

    # the above works. I have the scaffolds arranged for plotting.

    # Plot in the order defined above
    f = CairoMakie.Figure(size=figureSize)
    numRows = length(scaffoldInRow)
    # make one axis object per row:
    axs = [Axis(f[i, 1], limits=(0, bpPerRow,
            0, 2.3), ylabel = "HetVar") for i in 1:numRows]
    for i in 1:numRows
        hidexdecorations!(axs[i]) #hide background lattice and axis labels
        hidespines!(axs[i], :t, :r, :b) # hide box around plot
    end

    for rowNum in 1:numRows
        numScaffoldsInRow = length(scaffoldInRow[rowNum])
        nextPlotShiftBP = 0
        for orderNum in 1:numScaffoldsInRow 
            scaffoldName = scaffoldInRow[rowNum][orderNum]
            plotBpLength = scaffold_lengths[findfirst(scaffolds_to_plot .== scaffoldName)]
            # select one scaffold from the whole genome:
            selection = windowed_pos_all.chrom .== scaffoldName 
            windowed_pos_selected = view(windowed_pos_all.mean_position, selection)
            windowed_HetVariance_selected = view(windowed_HetVariance_all, selection)
            if length(windowed_pos_selected) > 0  # only plot if there is data for that scaffold        
                text!(axs[rowNum], scaffoldBpStartInRow[rowNum][orderNum] + 0.005bpPerRow, 2.1; text=scaffoldName, align=(:left, :center), fontsize=20)
                xx = vcat(first(windowed_pos_selected), windowed_pos_selected, last(windowed_pos_selected)) .+ scaffoldBpStartInRow[rowNum][orderNum]
                yy = vcat(0, windowed_HetVariance_selected, 0)
                poly!(axs[rowNum], Point2f.(xx, yy), color = (fillColor, fillTransparency), strokecolor = (fillColor, lineTransparency), strokewidth = 1)
                # if indicating regions (e.g. that have high HetVar)
                if plotRegions
                    regionsToPlot_thisScaffold = regionsToPlot[regionsToPlot.regionChrom .== scaffoldName, :]
                    for i in eachindex(regionsToPlot_thisScaffold.regionStart)
                        xValues = [regionsToPlot_thisScaffold.regionStart[i], regionsToPlot_thisScaffold.regionEnd[i]] .+ scaffoldBpStartInRow[rowNum][orderNum]
                        yValues = [0.05, 0.05]
                        lines!(axs[rowNum], xValues, yValues, color="red", linewidth=10)
                    end
                end
            end
        end
    end
    display(f)
end


plotGenomeHetVariance(scaffolds_to_plot, 
                        windowed_HetVariance_all,
                        windowed_pos_all;
                        fillColor = "purple",
                        lineTransparency = 0.8,
                        fillTransparency = 0.2,
                        figureSize=(1200, 1200),
                        plotRegions = true,
                        regionsToPlot = highHetVarRegions)

```

# Choose low-het individuals in a high HetVar region

Now that we have high HetVar regions indicated, we can automate the choosing of essential homozygous individuals in those regions. Below I will do this for chrZ (and later chr15 and chr18).

First, here's two functions, first for getting the boundaries of the longest high HetVar region from a scaffold, second for getting a bunch of info about the region:

```{julia}
function getOneHighHetVarRegion(highHetVarRegions, chr)
    selection = (highHetVarRegions.regionChrom .== chr)
    if sum(selection) == 1
        println("Good news: 1 region on that scaffold")
        positionMin = highHetVarRegions.regionStart[selection][1]
        positionMax = highHetVarRegions.regionEnd[selection][1]
        regionText = string("chr ", chr, " ",positionMin," to ",positionMax)
    elseif sum(selection) > 1
        println("More than 1 region on that scaffold. Using just the longest one.")
        highHetVarRegions_chr = highHetVarRegions[selection, :]
        display(highHetVarRegions_chr)
        # get biggest region (first one if tied):
        regionSizes = highHetVarRegions_chr.regionEnd .- highHetVarRegions_chr.regionStart
        indexOfLongest = findfirst(regionSizes .== maximum(regionSizes))
        positionMin = highHetVarRegions_chr.regionStart[indexOfLongest]
        positionMax = highHetVarRegions_chr.regionEnd[indexOfLongest]
        regionText = string("chr ", chr, " ",positionMin," to ",positionMax)
    elseif sum(selection) == 0
        println("No high HetVar regions on that scaffold")
        return
    end
    return positionMin, positionMax, regionText
end


function getWindowedIndHetStanRegion(genos, pos, 
                                    highHetVarRegions, chr;
                                    windowSize = 500)
    # remake the windowedIndHet_standardized (done above in a different cell)
    loci_selection = (pos.chrom .== chr)
    pos_region = pos[loci_selection, :]
    genotypes_region = genos[:, loci_selection]
    windowedPos, windowedIndHet = getWindowedIndHet(genotypes_region, pos_region, windowSize)
    windowedIndHet_standardized = standardizeIndHet(windowedIndHet)
    # look up the boundaries of the high HetVar region:
    positionMin, positionMax, regionText = getOneHighHetVarRegion(highHetVarRegions, chr)
    # choose just the windows that are in the high HetVar region:
    window_selection = (positionMin .< windowedPos .< positionMax)
    windowedIndHetStanRegion = windowedIndHet_standardized[:,window_selection]
    meanAcrossRegionIndHetStan = mean.(eachrow(windowedIndHetStanRegion)) 
    # choose loci in region
    lociSelection = (positionMin .< pos_region.position .< positionMax)
    pos_highHetVarRegion = pos_region[lociSelection, :]
    genos_highHetVarRegion = genotypes_region[:, lociSelection]
    # convert `-1` genotypes (which indicates missing) to `missing`:
    replace!(genos_highHetVarRegion, -1 => missing)
    regionInfo = chooseChrRegion(pos_highHetVarRegion, chr; positionMin=positionMin, positionMax=positionMax) # this makes appropriate text describing the region
    return positionMin, positionMax, regionText, 
            windowedIndHetStanRegion, meanAcrossRegionIndHetStan,
            genos_highHetVarRegion, pos_highHetVarRegion, regionInfo
end
```

```{julia}
# choose scaffold
chr = "gwZ"

positionMin, positionMax, regionText, 
    windowedIndHetStanRegion, meanAcrossRegionIndHetStan,
    genos_highHetVarRegion, pos_highHetVarRegion, regionInfo = 
    getWindowedIndHetStanRegion(genosOnly_included, 
                            pos_SNP_filtered, 
                            highHetVarRegions, chr;
                            windowSize = 500)

# inspect values for mean IndHetStan per individual for that high HetVar region
plot(meanAcrossRegionIndHetStan)

# Add column to metadata containing the regionIndHetStan for this highHet region:
command = "ind_with_metadata_included." * chr * "_regionIndHetStan = meanAcrossRegionIndHetStan"
eval(Meta.parse(command)) # this executes the command constructed above
ind_with_metadata_included.regionIndHetStan = meanAcrossRegionIndHetStan

#names(ind_with_metadata_included)

# check whether missing data related to heterozygosity (good news: not really)
plot(ind_with_metadata_included.numMissings, meanAcrossRegionIndHetStan)

# to inspect data, sort by regionIndHetStan :
#ind_with_metadata_included_sortedbyHetVar = sort(ind_with_metadata_included, [:regionIndHetStan])

# PCA of all individuals:

genos_highHetVarRegion_imputed = Impute.svd(Matrix{Union{Missing, Float32}}(genos_highHetVarRegion))

flipPC1 = true
flipPC2 = false

PCAmodelAll = plotPCA(genos_highHetVarRegion_imputed, ind_with_metadata_included, 
            groups_to_plot_PCA, group_colors_PCA; 
            sampleSet = "greenish warblers", regionText = regionText,
            flip1 = flipPC1, flip2 = flipPC2,
            lineOpacity = 0.7, fillOpacity = 0.6,
            symbolSize = 14, showTitle = true,
            xLabelText = string("Region PC1"), yLabelText = string("Region PC2"),
            showPlot = false)

display(PCAmodelAll.PCAfig)


# choose inds with low IndHet in high HetVar region:
indSelection = (meanAcrossRegionIndHetStan .< 1.75)    # 0.75
ind_with_metadata_lowIndHetStan = ind_with_metadata_included[indSelection, :]

genos_lowIndHetStan = genos_highHetVarRegion[indSelection, :]

# check that missing genotypes are encoded as `missing` rather than `-1`:
if sum(ismissing.(genos_lowIndHetStan)) == 0
    println("Warning: No `missing` genotypes to be imputed")
end

# impute missing genotypes:

genos_lowIndHetStan_imputed = Impute.svd(Matrix{Union{Missing, Float32}}(genos_lowIndHetStan))

flipPC1 = true
flipPC2 = true

PCAmodel = plotPCA(genos_lowIndHetStan_imputed, ind_with_metadata_lowIndHetStan, 
            groups_to_plot_PCA, group_colors_PCA; 
            sampleSet = "greenish warblers (lowIndHetStan)", regionText = regionText,
            flip1 = flipPC1, flip2 = flipPC2,
            lineOpacity = 0.7, fillOpacity = 0.6,
            symbolSize = 14, showTitle = true,
            xLabelText = string("Region PC1"), yLabelText = string("Region PC2"),
            showPlot = false)

display(PCAmodel.PCAfig)

# Add PC values to metadata for individuals included in PCA above:
PCAmodel.metadata.PC1 = PCAmodel.values[1,:]
PCAmodel.metadata.PC2 = PCAmodel.values[2,:]
PCAmodel.metadata.PC3 = PCAmodel.values[3,:]

```

# Plot PC1 vs. PC2:

```{julia}
f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title = "PC1 vs. PC2",
    xlabel = "Region PC1", xlabelsize = 24,
    ylabel = "Region PC2", ylabelsize = 24,
    autolimitaspect = 1)
hidedecorations!(ax, label = false, ticklabels = false, ticks = false) # hide background lattice
for i in eachindex(groups_to_plot_PCA) 
    selection = PCAmodel.metadata.Fst_group .== groups_to_plot_PCA[i]
    CairoMakie.scatter!(ax, PCAmodel.metadata.PC1[selection], PCAmodel.metadata.PC2[selection], marker = :diamond, color = (group_colors_PCA[i], 0.6), markersize = 14, strokewidth=0.5, strokecolor = ("black", 0.7))
end
display(f)
```

# Plot PC1 vs. PC3:

```{julia}
f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title = "PC1 vs. PC3",
    xlabel = "Region PC1", xlabelsize = 24,
    ylabel = "Region PC3", ylabelsize = 24,
    autolimitaspect = 1)
hidedecorations!(ax, label = false, ticklabels = false, ticks = false) # hide background lattice
for i in eachindex(groups_to_plot_PCA) 
    selection = PCAmodel.metadata.Fst_group .== groups_to_plot_PCA[i]
    CairoMakie.scatter!(ax, PCAmodel.metadata.PC1[selection], PCAmodel.metadata.PC3[selection], marker = :diamond, color = (group_colors_PCA[i], 0.6), markersize = 14, strokewidth=0.5, strokecolor = ("black", 0.7))
end
display(f)
```

# Now it is clear that there are six clear haplogroups of Z high HetVar region. Divide samples into those groups, based on PCA scores, and then calculate pi within and pi between

```{julia}
# Inspect Z chromosome PCA of low IndHet (< 1.75) individuals,
# and specify group boundaries:

clusterNames = ["vir",
                "lud",
                "nit",
                "troch",
                "obs",
                "plumb"]

clusterColors = ["blue",
                "seagreen4",
                "grey",
                "yellow",
                "orange",
                "red"]

vir = (5 .< PCAmodel.metadata.PC1) .&& (PCAmodel.metadata.PC3 .< 2)
lud = (5 .< PCAmodel.metadata.PC1) .&& (2 .< PCAmodel.metadata.PC3)
nit = (2 .< PCAmodel.metadata.PC1 .< 4)
troch = PCAmodel.metadata.PC2 .> 5
obs = (-2 .< PCAmodel.metadata.PC1 .< 2) .&& (1 .< PCAmodel.metadata.PC2 .< 4)
plumb = PCAmodel.metadata.PC1 .< -5

# check the individuals in each group
PCAmodel.metadata.Fst_group[vir]
PCAmodel.metadata.Fst_group[lud]
PCAmodel.metadata.Fst_group[nit] # note there are two nitidus with nearly identical values
PCAmodel.metadata.Fst_group[troch]
PCAmodel.metadata.Fst_group[obs]
PCAmodel.metadata.Fst_group[plumb]

clusterArray = [vir lud nit troch obs plumb]

# create vectors that indicate the groups and plot order for this analysis:
clusterMembership = fill("none", nrow(PCAmodel.metadata))
plotOrder = fill(-9, nrow(PCAmodel.metadata))
for i in eachindex(clusterArray[1,:])
    clusterMembership[clusterArray[:,i]] .= clusterNames[i]
    plotOrder[clusterArray[:,i]] .= i
end

# Calculate allele freqs and sample sizes
freqs, sampleSizes = getFreqsAndSampleSizes(genos_lowIndHetStan, clusterMembership, clusterNames)
println("Calculated population allele frequencies and sample sizes")

# NOTE THAT FOR Z CHR, SHOULD REALLY CORRECT FREQS AND SAMPLESIZE FOR SEX (BECAUSE ONE Z FEMALES AND 2 Z MALES)--MODIFY THE getFreqsAndSampleSizes FUNCTION.

# Calculate per-site pi (within-group nucleotide distance)

sitePi = getSitePi(freqs, sampleSizes)

# calculate pairwise Dxy per site, using data in "freqs" and groups in "groups"

Dxy, pairwiseDxyClusterNames = getDxy(freqs, clusterNames)

Fst, FstNumerator, FstDenominator, pairwiseFstClusterNames = getFst(freqs, sampleSizes, clusterNames; among=false)  # set among to FALSE if no among Fst wanted (some things won't work without it) 

# Now get averages of pi and Dxy for whole region:

regionPiTable = DataFrame(cluster = clusterNames, pi = getRegionPi(sitePi))

regionDxyTable = DataFrame(cluster_pair = pairwiseDxyClusterNames, Dxy = getRegionDxy(Dxy))

#= julia> regionDxyTable
15×2 DataFrame
 Row │ cluster_pair  Dxy       
     │ String        Float64   
─────┼─────────────────────────
   1 │ vir_lud       0.0171473
   2 │ vir_nit       0.0387239
   3 │ vir_troch     0.0409623
   4 │ vir_obs       0.0375541
   5 │ vir_plumb     0.0466223
   6 │ lud_nit       0.0364196
   7 │ lud_troch     0.0388527
   8 │ lud_obs       0.0354389
   9 │ lud_plumb     0.0443947
  10 │ nit_troch     0.0463029
  11 │ nit_obs       0.0427271
  12 │ nit_plumb     0.0523756
  13 │ troch_obs     0.0266454
  14 │ troch_plumb   0.0403336
  15 │ obs_plumb     0.0365672 =#

# It seems the distances are not very consistent with a bifurcating tree,
# nor 1-D isolation by distance, but something more complex.
# Obscuratus is closer to viridanus than troch is.
# Nitidus quite distant but gets put in centre of PCA because off on its own axis.

# Make a genotype-by-individual plot using all variable loci in the region,
# by setting `Fst_cutoff` to super low value
groupsToCompare = "vir_plumb"
Fst_cutoff = -100 # super low to show all SNPs
missingFractionAllowed = 0.1
# in metadata, replace `Fst_group` column with cluster info (needed for the function below):
PCAmodel.metadata.Fst_group = clusterMembership
PCAmodel.metadata.plot_order = plotOrder

# limit the SNPs to those with variants greater than 50% in 
# at least one pop, and less than 50% in at least one pop.
# (So for each column in `freqs`, the maximum should be > 0.5 
# and the minimum should be < 0.5)
selectedSNPs = (vec(maximum(freqs, dims=1)) .> 0.5) .& (vec(minimum(freqs, dims=1)) .< 0.5)
genos_selectedSNPs = genos_lowIndHetStan[:, selectedSNPs]
pos_selectedSNPs = pos_highHetVarRegion[selectedSNPs, :]
Fst_selectedSNPs = Fst[:, selectedSNPs]
freqs_selectedSNPs = freqs[:, selectedSNPs]

# limit the number of individuals per group to plot
numIndsToPlot = [15, 15, 15, 15, 15, 15]

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNames, numIndsToPlot, 
                                            genos_selectedSNPs, PCAmodel.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs, clusterNames, clusterColors;
                missingFractionAllowed = missingFractionAllowed)
```

# Do a PCA based on above info, on just the west side of the ring

```{julia}
groups_to_plot_PCA_westside = ["vir","vir_S","nit", "lud_PK", "lud_KS", "lud_central", "lud_Sath", "lud_ML","troch_west","troch_LN"]
group_colors_PCA_westside = ["blue","turquoise1","grey","seagreen4","seagreen3","seagreen2","olivedrab3","olivedrab2","olivedrab1","yellow"]

# without nitidus:
groups_to_plot_PCA_westside = ["vir","vir_S", "lud_PK", "lud_KS", "lud_central", "lud_Sath", "lud_ML","troch_west","troch_LN"]
group_colors_PCA_westside = ["blue","turquoise1","seagreen4","seagreen3","seagreen2","olivedrab3","olivedrab2","olivedrab1","yellow"]

PCAmodel = plotPCA(genos_lowIndHetStan_imputed, ind_with_metadata_lowIndHetStan, 
            groups_to_plot_PCA_westside, group_colors_PCA_westside; 
            sampleSet = "greenish warblers (west side)", regionText = regionText,
            flip1 = flipPC1, flip2 = flipPC2,
            lineOpacity = 0.7, fillOpacity = 0.6,
            symbolSize = 14, showTitle = true,
            xLabelText = string("Region PC1"), yLabelText = string("Region PC2"),
            showPlot = false)

display(PCAmodel.PCAfig)
```


# Do a PCA based on above info, on just the east side of the ring

```{julia}
groups_to_plot_PCA_eastside = ["troch_LN","troch_EM","obs","plumb_BJ","plumb","plumb_vir"]
group_colors_PCA_eastside = ["yellow","gold","orange","pink","red","purple"];

PCAmodel = plotPCA(genos_lowIndHetStan_imputed, ind_with_metadata_lowIndHetStan, 
            groups_to_plot_PCA_eastside, group_colors_PCA_eastside; 
            sampleSet = "greenish warblers (east side)", regionText = regionText,
            flip1 = flipPC1, flip2 = flipPC2,
            lineOpacity = 0.7, fillOpacity = 0.6,
            symbolSize = 14, showTitle = true,
            xLabelText = string("Region PC1"), yLabelText = string("Region PC2"),
            showPlot = false)

display(PCAmodel.PCAfig)
```


# Do a PCA based on a same-size region elsewhere on the Z (with low HetVar):

```{julia}
# get length of region
lengthHighHetVarRegion = positionMax - positionMin

leftLocus = 10_000_000 # start at very left side, or 10 Mb in
rightLocus = leftLocus + lengthHighHetVarRegion
regionText_lowHetVarRegion = string("chr ", chr, " ",leftLocus," to ",rightLocus)

lociSelection = (leftLocus .<= pos_region.position .<= rightLocus)
genotypes_lowHetVarRegion = genotypes_region[:, lociSelection]

# impute missing genotypes:

genotypes_lowHetVarRegion_imputed = Impute.svd(Matrix{Union{Missing, Float32}}(genotypes_lowHetVarRegion))

flipPC1 = true
flipPC2 = true

PCAmodel = plotPCA(genotypes_lowHetVarRegion_imputed, ind_with_metadata_included, 
            groups_to_plot_PCA, group_colors_PCA; 
            sampleSet = "greenish warblers", regionText = regionText_lowHetVarRegion,
            flip1 = flipPC1, flip2 = flipPC2,
            lineOpacity = 0.7, fillOpacity = 0.6,
            symbolSize = 14, showTitle = true,
            xLabelText = string("Region PC1"), yLabelText = string("Region PC2"),
            showPlot = false)

display(PCAmodel.PCAfig)
```




## Do similar as above chr Z analysis but for chr 15:

```{julia}
# choose scaffold
chr = "gw15"

positionMin, positionMax, regionText, 
    windowedIndHetStanRegion, meanAcrossRegionIndHetStan,
    genos_highHetVarRegion, pos_highHetVarRegion, regionInfo = 
    getWindowedIndHetStanRegion(genosOnly_included, 
                            pos_SNP_filtered, 
                            highHetVarRegions, chr;
                            windowSize = 500)

# inspect values for mean IndHetStan per individual for that high HetVar region
plot(meanAcrossRegionIndHetStan)

# Add column to metadata containing the regionIndHetStan for this highHet region:
command = "ind_with_metadata_included." * chr * "_regionIndHetStan = meanAcrossRegionIndHetStan"
eval(Meta.parse(command)) # this executes the command constructed above
ind_with_metadata_included.regionIndHetStan = meanAcrossRegionIndHetStan

#names(ind_with_metadata_included)

# check whether missing data related to heterozygosity (good news: not really)
plot(ind_with_metadata_included.numMissings, meanAcrossRegionIndHetStan)

# PCA of all individuals:

genos_highHetVarRegion_imputed = Impute.svd(Matrix{Union{Missing, Float32}}(genos_highHetVarRegion))

flipPC1 = true
flipPC2 = true

PCAmodelAll = plotPCA(genos_highHetVarRegion_imputed, ind_with_metadata_included, 
            groups_to_plot_PCA, group_colors_PCA; 
            sampleSet = "greenish warblers", regionText = regionText,
            flip1 = flipPC1, flip2 = flipPC2,
            lineOpacity = 0.7, fillOpacity = 0.6,
            symbolSize = 14, showTitle = true,
            xLabelText = string("Region PC1"), yLabelText = string("Region PC2"),
            showPlot = false)

display(PCAmodelAll.PCAfig)

# Add PC values to metadata for individuals included in PCA above:
if flipPC1
    PCAmodelAll.metadata.PC1 = -1 .* PCAmodelAll.values[1,:]
else 
    PCAmodelAll.metadata.PC1 = PCAmodelAll.values[1,:]
end
if flipPC2
    PCAmodelAll.metadata.PC2 = -1 .* PCAmodelAll.values[2,:]
else
    PCAmodelAll.metadata.PC2 = PCAmodelAll.values[2,:]
end
PCAmodelAll.metadata.PC3 = PCAmodelAll.values[3,:]

# For the next bit to work with above, make sure that all individuals in the above `plotPCA` command
# are included in the `groups_to_plot_PCA`

# choose inds with low IndHet in high HetVar region:
indSelection_lowIndHetStan = (meanAcrossRegionIndHetStan .< 1.75) 

#Plot only the lowIndHetStan individuals:

f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title = "PC1 vs. PC2, only low heterozygosity",
    xlabel = "Region PC1", xlabelsize = 24,
    ylabel = "Region PC2", ylabelsize = 24,
    autolimitaspect = 1)
hidedecorations!(ax, label = false, ticklabels = false, ticks = false) # hide background lattice
for i in eachindex(groups_to_plot_PCA) 
    selection = (PCAmodelAll.metadata.Fst_group .== groups_to_plot_PCA[i]) .& indSelection_lowIndHetStan
    CairoMakie.scatter!(ax, PCAmodelAll.metadata.PC1[selection], PCAmodelAll.metadata.PC2[selection], marker = :diamond, color = (group_colors_PCA[i], 0.6), markersize = 14, strokewidth=0.5, strokecolor = ("black", 0.7))
end
display(f)

```

### Save the individual colors in the metadata

```{julia}
indColors = fill("", size(PCAmodelAll.metadata, 1))
for i in axes(PCAmodelAll.metadata, 1)
    indColors[i] = group_colors_PCA[findfirst(groups_to_plot_PCA .== PCAmodelAll.metadata.Fst_group[i])]
end
PCAmodelAll.metadata.indColorLeft = indColors
PCAmodelAll.metadata.indColorRight = indColors
```

# Plot PC1 vs. PC2:

```{julia}
f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title = "PC1 vs. PC2",
    xlabel = "Region PC1", xlabelsize = 24,
    ylabel = "Region PC2", ylabelsize = 24,
    autolimitaspect = 1)
hidedecorations!(ax, label = false, ticklabels = false, ticks = false) # hide background lattice
for i in eachindex(groups_to_plot_PCA) 
    selection = PCAmodelAll.metadata.Fst_group .== groups_to_plot_PCA[i]
    CairoMakie.scatter!(ax, PCAmodelAll.metadata.PC1[selection], PCAmodelAll.metadata.PC2[selection], marker = :diamond, color = (group_colors_PCA[i], 0.6), markersize = 14, strokewidth=0.5, strokecolor = ("black", 0.7))
end
display(f)
```

# Plot PC1 vs. PC3:

```{julia}
f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title = "PC1 vs. PC3",
    xlabel = "Region PC1", xlabelsize = 24,
    ylabel = "Region PC3", ylabelsize = 24,
    autolimitaspect = 1)
hidedecorations!(ax, label = false, ticklabels = false, ticks = false) # hide background lattice
for i in eachindex(groups_to_plot_PCA) 
    selection = PCAmodelAll.metadata.Fst_group .== groups_to_plot_PCA[i]
    CairoMakie.scatter!(ax, PCAmodelAll.metadata.PC1[selection], PCAmodelAll.metadata.PC3[selection], marker = :diamond, color = (group_colors_PCA[i], 0.6), markersize = 14, strokewidth=0.5, strokecolor = ("black", 0.7))
end
display(f)
```


# At chr 15 high HetVar region, there are only 5 clear haplogroups. Divide samples into those groups, based on PCA scores, and then calculate pi within and pi between

```{julia}

clusterNames = ["virLud",
                "nit",
                "troch",
                "obs",
                "plumb"]

clusterColors = ["green",
                "grey",
                "yellowgreen",
                "orange",
                "red"]

virLud = (PCAmodelAll.metadata.PC1 .< -5) .& 
            indSelection_lowIndHetStan
nit = (-5 .< PCAmodelAll.metadata.PC1 .< -2.5) .&
            indSelection_lowIndHetStan
troch = (-1 .< PCAmodelAll.metadata.PC1 .< 2.5) .&
            (PCAmodelAll.metadata.PC3 .< 1) .&
            indSelection_lowIndHetStan
obs = (0 .< PCAmodelAll.metadata.PC1 .< 3) .&
            (-5.5 .< PCAmodelAll.metadata.PC2 .< -3) .& 
            indSelection_lowIndHetStan
plumb = (7 .< PCAmodelAll.metadata.PC1) .& 
            indSelection_lowIndHetStan

# check the individuals in each group
PCAmodelAll.metadata.Fst_group[virLud]
PCAmodelAll.metadata.Fst_group[nit]
PCAmodelAll.metadata.Fst_group[troch]
PCAmodelAll.metadata.Fst_group[obs]
PCAmodelAll.metadata.Fst_group[plumb]

clusterArray = [virLud nit troch obs plumb]

# show numbers in each group
println("The numbers in each group are $(sum(clusterArray, dims=1)) and the sum of those is $(sum(sum(clusterArray, dims=1)))")

# create vectors that indicate the groups and plot order for this analysis:
clusterMembership = fill("none", nrow(PCAmodelAll.metadata))
plotOrder = fill(-9, nrow(PCAmodelAll.metadata))
for i in eachindex(clusterArray[1,:])
    clusterMembership[clusterArray[:,i]] .= clusterNames[i]
    plotOrder[clusterArray[:,i]] .= i
end

# Calculate allele freqs and sample sizes
freqs, sampleSizes = getFreqsAndSampleSizes(genos_highHetVarRegion, clusterMembership, clusterNames)
println("Calculated population allele frequencies and sample sizes")

# Calculate per-site pi (within-group nucleotide distance)

sitePi = getSitePi(freqs, sampleSizes)

# calculate pairwise Dxy per site, using data in "freqs" and groups in "groups"

Dxy, pairwiseDxyClusterNames = getDxy(freqs, clusterNames)

Fst, FstNumerator, FstDenominator, pairwiseFstClusterNames = getFst(freqs, sampleSizes, clusterNames; among=false)  # set among to FALSE if no among Fst wanted (some things won't work without it) 

# Now get averages of pi and Dxy for whole region:

regionPiTable = DataFrame(cluster = clusterNames, pi = getRegionPi(sitePi))
#= 5×2 DataFrame
 Row │ cluster  pi         
     │ String   Float64    
─────┼─────────────────────
   1 │ virLud   0.00892738
   2 │ nit      0.00677711
   3 │ troch    0.00725483
   4 │ obs      0.0083953
   5 │ plumb    0.00673292 =#

regionDxyTable = DataFrame(cluster_pair = pairwiseDxyClusterNames, Dxy = getRegionDxy(Dxy))
#= 10×2 DataFrame
 Row │ cluster_pair  Dxy       
     │ String        Float64   
─────┼─────────────────────────
   1 │ virLud_nit    0.032793
   2 │ virLud_troch  0.0326016
   3 │ virLud_obs    0.0334515
   4 │ virLud_plumb  0.041869
   5 │ nit_troch     0.0389012
   6 │ nit_obs       0.0393449
   7 │ nit_plumb     0.0476769
   8 │ troch_obs     0.0150895
   9 │ troch_plumb   0.0294242
  10 │ obs_plumb     0.0297807 =#

# Make a genotype-by-individual plot using all variable loci in the region,
missingFractionAllowed = 0.1
# in metadata, replace `Fst_group` column with cluster info (needed for the function below):
PCAmodelAll.metadata.Fst_group = clusterMembership
PCAmodelAll.metadata.plot_order = plotOrder

# limit the SNPs to those with variants greater than 50% in 
# at least one pop, and less than 50% in at least one pop.
# (So for each column in `freqs`, the maximum should be > 0.5 
# and the minimum should be < 0.5)
selectedSNPs = (vec(maximum(freqs, dims=1)) .> 0.5) .& (vec(minimum(freqs, dims=1)) .< 0.5)
genos_selectedSNPs = genos_highHetVarRegion[:, selectedSNPs]
pos_selectedSNPs = pos_highHetVarRegion[selectedSNPs, :]
Fst_selectedSNPs = Fst[:, selectedSNPs]
freqs_selectedSNPs = freqs[:, selectedSNPs]

# limit the number of individuals per group to plot
numIndsToPlot = [15, 15, 15, 15, 15, 15]

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNames, numIndsToPlot, 
                                            genos_selectedSNPs, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs, clusterNames, clusterColors;
                missingFractionAllowed = missingFractionAllowed,
                indColorRightProvided = true)
```

## Now show a GBI plot like above, but with heterozygotes:

```{julia}

clusterNamesWithHets = ["virLud",
                        "nit",
                        "virLud_troch",
                        "troch",
                        "obs",
                        "plumb",
                        "vir_plumb"]

clusterColorsWithHets = ["blue",
                        "grey",
                        "yellowgreen",
                        "yellow",
                        "orange",
                        "red",
                        "purple"]

virLud_troch = (-5 .< PCAmodelAll.metadata.PC1 .< 0) .&
                (-5.5 .< PCAmodelAll.metadata.PC2 .< 0) .&
                 .!indSelection_lowIndHetStan
vir_plumb = (-2 .< PCAmodelAll.metadata.PC1 .< 2) .&
                (3 .< PCAmodelAll.metadata.PC2 .< 5.5) .&
                 .!indSelection_lowIndHetStan

clusterArray = [virLud nit virLud_troch troch obs plumb vir_plumb]

sum(clusterArray, dims=1)

if sum(sum(clusterArray, dims=1)) == size(PCAmodelAll.metadata, 1)
    println("Good news: Individuals included in a group matches total number of individuals")
else 
    println("Warning: Individuals included in a group ($(sum(sum(clusterArray, dims=1)))) do NOT match total number of individuals ($(size(PCAmodelAll.metadata, 1)))")
end

# create vectors that indicate the groups and plot order for this analysis:
clusterMembershipWithHets = fill("none", nrow(PCAmodelAll.metadata))
plotOrderWithHets = fill(-9, nrow(PCAmodelAll.metadata))
for i in eachindex(clusterArray[1,:])
    clusterMembershipWithHets[clusterArray[:,i]] .= clusterNamesWithHets[i]
    plotOrderWithHets[clusterArray[:,i]] .= i
end

# Add column to main metadata object containing the cluster membership for this highHet region:
command = "ind_with_metadata_included." * chr * "_cluster = clusterMembershipWithHets"
eval(Meta.parse(command)) # this executes the command constructed above

# in metadata, replace `Fst_group` column with cluster info (needed for the function below):
PCAmodelAll.metadata.Fst_group = clusterMembershipWithHets
PCAmodelAll.metadata.plot_order = plotOrderWithHets

# limit the number of individuals per group to plot
numIndsToPlotWithHets = fill(15, length(clusterNamesWithHets))

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNamesWithHets, numIndsToPlotWithHets, 
                                            genos_selectedSNPs, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs, clusterNamesWithHets, clusterColorsWithHets;
                missingFractionAllowed = missingFractionAllowed,
                indColorLeftProvided = false,
                indColorRightProvided = true)
```

## Show just the west area (without nitidus)

```{julia}

clusterNamesWithHetsWest = ["virLud",
                        "virLud_troch",
                        "troch"]

clusterColorsWithHetsWest = ["blue",
                        "yellowgreen",
                        "yellow"]

# limit the SNPs to those with variants greater than 50% in 
# at least one pop, and less than 50% in at least one pop.
# (So for each column in `freqs`, the maximum should be > 0.5 
# and the minimum should be < 0.5)
# Calculate allele freqs and sample sizes
freqs, sampleSizes = getFreqsAndSampleSizes(genos_selectedSNPs, clusterMembershipWithHets, clusterNamesWithHetsWest)
println("Calculated population allele frequencies and sample sizes")
selectedSNPs = (vec(maximum(freqs, dims=1)) .> 0.5) .& (vec(minimum(freqs, dims=1)) .< 0.5)
genos_selectedSNPs2 = genos_selectedSNPs[:, selectedSNPs]
pos_selectedSNPs2 = pos_selectedSNPs[selectedSNPs, :]
freqs_selectedSNPs2 = freqs[:, selectedSNPs]

numIndsToPlotWithHets = [100, 100, 100]

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNamesWithHetsWest, numIndsToPlotWithHets, 
                                            genos_selectedSNPs2, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs2,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs2, clusterNamesWithHetsWest, clusterColorsWithHetsWest;
                missingFractionAllowed = missingFractionAllowed,
                indColorLeftProvided = false,
                indColorRightProvided = true)

```

## Show just the east area

```{julia}

clusterNamesWithHetsWest = ["troch",
                            "obs",
                            "plumb"]

clusterColorsWithHetsWest = ["yellow",
                            "orange",
                            "red"]

# limit the SNPs to those with variants greater than 50% in 
# at least one pop, and less than 50% in at least one pop.
# (So for each column in `freqs`, the maximum should be > 0.5 
# and the minimum should be < 0.5)
# Calculate allele freqs and sample sizes
freqs, sampleSizes = getFreqsAndSampleSizes(genos_selectedSNPs, clusterMembershipWithHets, clusterNamesWithHetsWest)
println("Calculated population allele frequencies and sample sizes")
selectedSNPs = (vec(maximum(freqs, dims=1)) .> 0.5) .& (vec(minimum(freqs, dims=1)) .< 0.5)
genos_selectedSNPs2 = genos_selectedSNPs[:, selectedSNPs]
pos_selectedSNPs2 = pos_selectedSNPs[selectedSNPs, :]
freqs_selectedSNPs2 = freqs[:, selectedSNPs]

numIndsToPlotWithHetsWest = fill(100, length(clusterNamesWithHetsWest))

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNamesWithHetsWest, numIndsToPlotWithHetsWest, 
                                            genos_selectedSNPs2, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs2,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs2, clusterNamesWithHetsWest, clusterColorsWithHetsWest;
                missingFractionAllowed = missingFractionAllowed,
                indColorLeftProvided = false,
                indColorRightProvided = true)

```

## Show just the northern area

```{julia}

clusterNamesWithHetsWest = ["virLud",
                            "vir_plumb",
                            "plumb"]

clusterColorsWithHetsWest = ["blue",
                            "purple",
                            "red"]

# limit the SNPs to those with variants greater than 50% in 
# at least one pop, and less than 50% in at least one pop.
# (So for each column in `freqs`, the maximum should be > 0.5 
# and the minimum should be < 0.5)
# Calculate allele freqs and sample sizes
freqs, sampleSizes = getFreqsAndSampleSizes(genos_selectedSNPs, clusterMembershipWithHets, clusterNamesWithHetsWest)
println("Calculated population allele frequencies and sample sizes")
selectedSNPs = (vec(maximum(freqs, dims=1)) .> 0.5) .& (vec(minimum(freqs, dims=1)) .< 0.5)
genos_selectedSNPs2 = genos_selectedSNPs[:, selectedSNPs]
pos_selectedSNPs2 = pos_selectedSNPs[selectedSNPs, :]
freqs_selectedSNPs2 = freqs[:, selectedSNPs]

numIndsToPlotWithHets = [100, 100, 100]

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNamesWithHetsWest, numIndsToPlotWithHets, 
                                            genos_selectedSNPs2, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs2,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs2, clusterNamesWithHetsWest, clusterColorsWithHetsWest;
                missingFractionAllowed = missingFractionAllowed,
                indColorLeftProvided = false,
                indColorRightProvided = true)

```


# Now do the same for chr 28

```{julia}
# choose scaffold
chr = "gw28"

positionMin, positionMax, regionText, 
    windowedIndHetStanRegion, meanAcrossRegionIndHetStan,
    genos_highHetVarRegion, pos_highHetVarRegion, regionInfo = 
    getWindowedIndHetStanRegion(genosOnly_included, 
                            pos_SNP_filtered, 
                            highHetVarRegions, chr;
                            windowSize = 500)

# inspect values for mean IndHetStan per individual for that high HetVar region
plot(meanAcrossRegionIndHetStan)

# Add column to metadata containing the regionIndHetStan for this highHet region:
command = "ind_with_metadata_included." * chr * "_regionIndHetStan = meanAcrossRegionIndHetStan"
eval(Meta.parse(command)) # this executes the command constructed above
ind_with_metadata_included.regionIndHetStan = meanAcrossRegionIndHetStan

#names(ind_with_metadata_included)

# check whether missing data related to heterozygosity (good news: not really)
plot(ind_with_metadata_included.numMissings, meanAcrossRegionIndHetStan)

# PCA of all individuals:

genos_highHetVarRegion_imputed = Impute.svd(Matrix{Union{Missing, Float32}}(genos_highHetVarRegion))

flipPC1 = true
flipPC2 = true

PCAmodelAll = plotPCA(genos_highHetVarRegion_imputed, ind_with_metadata_included, 
            groups_to_plot_PCA, group_colors_PCA; 
            sampleSet = "greenish warblers", regionText = regionText,
            flip1 = flipPC1, flip2 = flipPC2,
            lineOpacity = 0.7, fillOpacity = 0.6,
            symbolSize = 14, showTitle = true,
            xLabelText = string("Region PC1"), yLabelText = string("Region PC2"),
            showPlot = false)

display(PCAmodelAll.PCAfig)

# Add PC values to metadata for individuals included in PCA above:
if flipPC1
    PCAmodelAll.metadata.PC1 = -1 .* PCAmodelAll.values[1,:]
else 
    PCAmodelAll.metadata.PC1 = PCAmodelAll.values[1,:]
end
if flipPC2
    PCAmodelAll.metadata.PC2 = -1 .* PCAmodelAll.values[2,:]
else
    PCAmodelAll.metadata.PC2 = PCAmodelAll.values[2,:]
end
PCAmodelAll.metadata.PC3 = PCAmodelAll.values[3,:]

# For the next bit to work with above, make sure that all individuals in the above `plotPCA` command
# are included in the `groups_to_plot_PCA`

# choose inds with low IndHet in high HetVar region:
indSelection_lowIndHetStan = (meanAcrossRegionIndHetStan .< 2) 

#Plot only the lowIndHetStan individuals:

f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title = "PC1 vs. PC2, only low heterozygosity",
    xlabel = "Region PC1", xlabelsize = 24,
    ylabel = "Region PC2", ylabelsize = 24,
    autolimitaspect = 1)
hidedecorations!(ax, label = false, ticklabels = false, ticks = false) # hide background lattice
for i in eachindex(groups_to_plot_PCA) 
    selection = (PCAmodelAll.metadata.Fst_group .== groups_to_plot_PCA[i]) .& indSelection_lowIndHetStan
    CairoMakie.scatter!(ax, PCAmodelAll.metadata.PC1[selection], PCAmodelAll.metadata.PC2[selection], marker = :diamond, color = (group_colors_PCA[i], 0.6), markersize = 14, strokewidth=0.5, strokecolor = ("black", 0.7))
end
display(f)

```

### Save the individual colors in the metadata

```{julia}
indColors = fill("", size(PCAmodelAll.metadata, 1))
for i in axes(PCAmodelAll.metadata, 1)
    indColors[i] = group_colors_PCA[findfirst(groups_to_plot_PCA .== PCAmodelAll.metadata.Fst_group[i])]
end
PCAmodelAll.metadata.indColorLeft = indColors
PCAmodelAll.metadata.indColorRight = indColors
```


# Plot PC1 vs. PC2:

```{julia}
f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title = "PC1 vs. PC2",
    xlabel = "Region PC1", xlabelsize = 24,
    ylabel = "Region PC2", ylabelsize = 24,
    autolimitaspect = 1)
hidedecorations!(ax, label = false, ticklabels = false, ticks = false) # hide background lattice
for i in eachindex(groups_to_plot_PCA) 
    selection = PCAmodelAll.metadata.Fst_group .== groups_to_plot_PCA[i]
    CairoMakie.scatter!(ax, PCAmodelAll.metadata.PC1[selection], PCAmodelAll.metadata.PC2[selection], marker = :diamond, color = (group_colors_PCA[i], 0.6), markersize = 14, strokewidth=0.5, strokecolor = ("black", 0.7))
end
display(f)
```

# Plot PC1 vs. PC3:

```{julia}
f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title = "PC1 vs. PC3",
    xlabel = "Region PC1", xlabelsize = 24,
    ylabel = "Region PC3", ylabelsize = 24,
    autolimitaspect = 1)
hidedecorations!(ax, label = false, ticklabels = false, ticks = false) # hide background lattice
for i in eachindex(groups_to_plot_PCA) 
    selection = PCAmodelAll.metadata.Fst_group .== groups_to_plot_PCA[i]
    CairoMakie.scatter!(ax, PCAmodelAll.metadata.PC1[selection], PCAmodelAll.metadata.PC3[selection], marker = :diamond, color = (group_colors_PCA[i], 0.6), markersize = 14, strokewidth=0.5, strokecolor = ("black", 0.7))
end
display(f)
```

# At chr 28 high HetVar region, there are only 4-5 clear haplogroups (yellow and orange are close). Divide samples into those groups, based on PCA scores, and then calculate pi within and pi between

```{julia}

clusterNames = ["virLud",
                "nit",
                "troch",
                "obs",
                "plumb"]

clusterColors = ["blue",
                "grey",
                "yellowgreen",
                "orange",
                "red"]

virLud = (PCAmodelAll.metadata.PC1 .< -4) .& indSelection_lowIndHetStan
nit = (-1 .< PCAmodelAll.metadata.PC1 .< 1) .& indSelection_lowIndHetStan
troch = (1 .< PCAmodelAll.metadata.PC1 .< 3) .& 
        (PCAmodelAll.metadata.PC2 .< -3.2) .& 
        indSelection_lowIndHetStan
obs = (1 .< PCAmodelAll.metadata.PC1 .< 2.5) .& 
        (-3.2 .< PCAmodelAll.metadata.PC2 .< -1) .&
        indSelection_lowIndHetStan
plumb = (3 .< PCAmodelAll.metadata.PC1) .& 
        (2.5 .< PCAmodelAll.PC2) .&
        indSelection_lowIndHetStan

# check the individuals in each group
PCAmodelAll.metadata.Fst_group[virLud]
PCAmodelAll.metadata.Fst_group[nit]
PCAmodelAll.metadata.Fst_group[troch]
PCAmodelAll.metadata.Fst_group[obs]
PCAmodelAll.metadata.Fst_group[plumb]

clusterArray = [virLud nit troch obs plumb]

# show numbers in each group
println("The numbers in each group are $(sum(clusterArray, dims=1)) and the sum of those is $(sum(sum(clusterArray, dims=1)))")

# create vectors that indicate the groups and plot order for this analysis:
clusterMembership = fill("none", nrow(PCAmodelAll.metadata))
plotOrder = fill(-9, nrow(PCAmodelAll.metadata))
for i in eachindex(clusterArray[1,:])
    clusterMembership[clusterArray[:,i]] .= clusterNames[i]
    plotOrder[clusterArray[:,i]] .= i
end

# Calculate allele freqs and sample sizes
freqs, sampleSizes = getFreqsAndSampleSizes(genos_highHetVarRegion, clusterMembership, clusterNames)
println("Calculated population allele frequencies and sample sizes")

# Calculate per-site pi (within-group nucleotide distance)

sitePi = getSitePi(freqs, sampleSizes)

# calculate pairwise Dxy per site, using data in "freqs" and groups in "groups"

Dxy, pairwiseDxyClusterNames = getDxy(freqs, clusterNames)

Fst, FstNumerator, FstDenominator, pairwiseFstClusterNames = getFst(freqs, sampleSizes, clusterNames; among=false)  # set among to FALSE if no among Fst wanted (some things won't work without it) 

# Now get averages of pi and Dxy for whole region:

regionPiTable = DataFrame(cluster = clusterNames, pi = getRegionPi(sitePi))
#= 5×2 DataFrame
 Row │ cluster  pi         
     │ String   Float64    
─────┼─────────────────────
   1 │ virLud   0.00792304
   2 │ nit      0.00320189
   3 │ troch    0.00734994
   4 │ obs      0.0101536
   5 │ plumb    0.00270239 =#

regionDxyTable = DataFrame(cluster_pair = pairwiseDxyClusterNames, Dxy = getRegionDxy(Dxy))
#= 10×2 DataFrame
 Row │ cluster_pair  Dxy       
     │ String        Float64   
─────┼─────────────────────────
   1 │ virLud_nit    0.0334156
   2 │ virLud_troch  0.0318841
   3 │ virLud_obs    0.0351279
   4 │ virLud_plumb  0.0330054
   5 │ nit_troch     0.0314387
   6 │ nit_obs       0.0344624
   7 │ nit_plumb     0.0307517
   8 │ troch_obs     0.0188902
   9 │ troch_plumb   0.0234771
  10 │ obs_plumb     0.0265753 =#

# Make a genotype-by-individual plot using all variable loci in the region,
missingFractionAllowed = 0.1
# in metadata, replace `Fst_group` column with cluster info (needed for the function below):
PCAmodelAll.metadata.Fst_group = clusterMembership
PCAmodelAll.metadata.plot_order = plotOrder

# limit the SNPs to those with variants greater than 50% in 
# at least one pop, and less than 50% in at least one pop.
# (So for each column in `freqs`, the maximum should be > 0.5 
# and the minimum should be < 0.5)
selectedSNPs = (vec(maximum(freqs, dims=1)) .> 0.5) .& (vec(minimum(freqs, dims=1)) .< 0.5)
genos_selectedSNPs = genos_highHetVarRegion[:, selectedSNPs]
pos_selectedSNPs = pos_highHetVarRegion[selectedSNPs, :]
Fst_selectedSNPs = Fst[:, selectedSNPs]
freqs_selectedSNPs = freqs[:, selectedSNPs]

# limit the number of individuals per group to plot
numIndsToPlot = [15, 15, 15, 15, 15, 15]

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNames, numIndsToPlot, 
                                            genos_selectedSNPs, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs, clusterNames, clusterColors;
                missingFractionAllowed = missingFractionAllowed,
                indColorRightProvided = true)
```

## Now show a GBI plot like above, but with heterozygotes:

```{julia}

clusterNamesWithHets = ["virLud",
                        "virLud_nit",
                        "nit",
                        "virLud_troch",
                        "troch",
                        "obs",
                        "obsHet",
                        "obs_plumb",
                        "plumb",
                        "vir_plumb"]

clusterColorsWithHets = ["blue",
                        "slateblue1",
                        "grey",
                        "yellowgreen",
                        "yellow",
                        "orange",
                        "darkgoldenrod1",
                        "darkorange1",
                        "red",
                        "purple"]

virLud_nit = (-4 .< PCAmodelAll.metadata.PC1 .< -2) .&
                (0 .< PCAmodelAll.metadata.PC2 .< 2) .&
                 .!indSelection_lowIndHetStan
virLud_troch = (-2.5 .< PCAmodelAll.metadata.PC1 .< 0) .&
                (-3.5 .< PCAmodelAll.metadata.PC2 .< 0) .&
                 .!indSelection_lowIndHetStan
obsHet = (1.5 .< PCAmodelAll.metadata.PC1 .< 3) .&
                (-3.5 .< PCAmodelAll.metadata.PC2 .< -1) .&
                 .!indSelection_lowIndHetStan
obs_plumb = (2.5 .< PCAmodelAll.metadata.PC1 .< 4) .&
                (-1 .< PCAmodelAll.metadata.PC2 .< 2) .&
                 .!indSelection_lowIndHetStan
vir_plumb = (-2 .< PCAmodelAll.metadata.PC1 .< 2) .&
                (2 .< PCAmodelAll.metadata.PC2 .< 4) .&
                 .!indSelection_lowIndHetStan

# check the individuals in each group
PCAmodelAll.metadata.Fst_group[virLud]
PCAmodelAll.metadata.Fst_group[virLud_nit]
PCAmodelAll.metadata.Fst_group[nit]
PCAmodelAll.metadata.Fst_group[virLud_troch]
PCAmodelAll.metadata.Fst_group[troch]
PCAmodelAll.metadata.Fst_group[obs]
PCAmodelAll.metadata.Fst_group[obsHet]
PCAmodelAll.metadata.Fst_group[obs_plumb]
PCAmodelAll.metadata.Fst_group[plumb]
PCAmodelAll.metadata.Fst_group[vir_plumb]

clusterArray = [virLud virLud_nit nit virLud_troch troch obs obsHet obs_plumb plumb vir_plumb]

sum(clusterArray, dims=1)

if sum(sum(clusterArray, dims=1)) == size(PCAmodelAll.metadata, 1)
    println("Good news: Individuals included in a group matches total number of individuals")
end

# create vectors that indicate the groups and plot order for this analysis:
clusterMembershipWithHets = fill("none", nrow(PCAmodelAll.metadata))
plotOrderWithHets = fill(-9, nrow(PCAmodelAll.metadata))
for i in eachindex(clusterArray[1,:])
    clusterMembershipWithHets[clusterArray[:,i]] .= clusterNamesWithHets[i]
    plotOrderWithHets[clusterArray[:,i]] .= i
end

# Add column to main metadata object containing the cluster membership for this highHet region:
command = "ind_with_metadata_included." * chr * "_cluster = clusterMembershipWithHets"
eval(Meta.parse(command)) # this executes the command constructed above

# in metadata, replace `Fst_group` column with cluster info (needed for the function below):
PCAmodelAll.metadata.Fst_group = clusterMembershipWithHets
PCAmodelAll.metadata.plot_order = plotOrderWithHets

# limit the number of individuals per group to plot
numIndsToPlotWithHets = fill(15, length(clusterNamesWithHets))

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNamesWithHets, numIndsToPlotWithHets, 
                                            genos_selectedSNPs, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs, clusterNamesWithHets, clusterColorsWithHets;
                missingFractionAllowed = missingFractionAllowed,
                indColorLeftProvided = false,
                indColorRightProvided = true)
```


## Show just the west area (without nitidus)

```{julia}

clusterNamesWithHetsWest = ["virLud",
                        "virLud_troch",
                        "troch"]

clusterColorsWithHetsWest = ["blue",
                        "yellowgreen",
                        "yellow"]

# limit the SNPs to those with variants greater than 50% in 
# at least one pop, and less than 50% in at least one pop.
# (So for each column in `freqs`, the maximum should be > 0.5 
# and the minimum should be < 0.5)
# Calculate allele freqs and sample sizes
freqs, sampleSizes = getFreqsAndSampleSizes(genos_selectedSNPs, clusterMembershipWithHets, clusterNamesWithHetsWest)
println("Calculated population allele frequencies and sample sizes")
selectedSNPs = (vec(maximum(freqs, dims=1)) .> 0.5) .& (vec(minimum(freqs, dims=1)) .< 0.5)
genos_selectedSNPs2 = genos_selectedSNPs[:, selectedSNPs]
pos_selectedSNPs2 = pos_selectedSNPs[selectedSNPs, :]
freqs_selectedSNPs2 = freqs[:, selectedSNPs]

numIndsToPlotWithHets = [100, 100, 100]

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNamesWithHetsWest, numIndsToPlotWithHets, 
                                            genos_selectedSNPs2, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs2,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs2, clusterNamesWithHetsWest, clusterColorsWithHetsWest;
                missingFractionAllowed = missingFractionAllowed,
                indColorLeftProvided = false,
                indColorRightProvided = true)

```


## Show just the east area

```{julia}

clusterNamesWithHetsWest = ["troch",
                            "obs",
                            "obsHet",
                            "obs_plumb",
                            "plumb"]

clusterColorsWithHetsWest = ["yellow",
                            "orange",
                            "darkgoldenrod1",
                            "darkorange1",
                            "red"]

# limit the SNPs to those with variants greater than 50% in 
# at least one pop, and less than 50% in at least one pop.
# (So for each column in `freqs`, the maximum should be > 0.5 
# and the minimum should be < 0.5)
# Calculate allele freqs and sample sizes
freqs, sampleSizes = getFreqsAndSampleSizes(genos_selectedSNPs, clusterMembershipWithHets, clusterNamesWithHetsWest)
println("Calculated population allele frequencies and sample sizes")
selectedSNPs = (vec(maximum(freqs, dims=1)) .> 0.5) .& (vec(minimum(freqs, dims=1)) .< 0.5)
genos_selectedSNPs2 = genos_selectedSNPs[:, selectedSNPs]
pos_selectedSNPs2 = pos_selectedSNPs[selectedSNPs, :]
freqs_selectedSNPs2 = freqs[:, selectedSNPs]

numIndsToPlotWithHets = [100, 100, 100, 100, 100]

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNamesWithHetsWest, numIndsToPlotWithHets, 
                                            genos_selectedSNPs2, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs2,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs2, clusterNamesWithHetsWest, clusterColorsWithHetsWest;
                missingFractionAllowed = missingFractionAllowed,
                indColorLeftProvided = false,
                indColorRightProvided = true)

```

## Show just the northern area

```{julia}

clusterNamesWithHetsWest = ["virLud",
                            "vir_plumb",
                            "plumb"]

clusterColorsWithHetsWest = ["blue",
                            "purple",
                            "red"]

# limit the SNPs to those with variants greater than 50% in 
# at least one pop, and less than 50% in at least one pop.
# (So for each column in `freqs`, the maximum should be > 0.5 
# and the minimum should be < 0.5)
# Calculate allele freqs and sample sizes
freqs, sampleSizes = getFreqsAndSampleSizes(genos_selectedSNPs, clusterMembershipWithHets, clusterNamesWithHetsWest)
println("Calculated population allele frequencies and sample sizes")
selectedSNPs = (vec(maximum(freqs, dims=1)) .> 0.5) .& (vec(minimum(freqs, dims=1)) .< 0.5)
genos_selectedSNPs2 = genos_selectedSNPs[:, selectedSNPs]
pos_selectedSNPs2 = pos_selectedSNPs[selectedSNPs, :]
freqs_selectedSNPs2 = freqs[:, selectedSNPs]

numIndsToPlotWithHets = [100, 100, 100]

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNamesWithHetsWest, numIndsToPlotWithHets, 
                                            genos_selectedSNPs2, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs2,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs2, clusterNamesWithHetsWest, clusterColorsWithHetsWest;
                missingFractionAllowed = missingFractionAllowed,
                indColorLeftProvided = false,
                indColorRightProvided = true)

```


# Now do the same for chr 26

```{julia}
# choose scaffold
chr = "gw26"

positionMin, positionMax, regionText, 
    windowedIndHetStanRegion, meanAcrossRegionIndHetStan,
    genos_highHetVarRegion, pos_highHetVarRegion, regionInfo = 
    getWindowedIndHetStanRegion(genosOnly_included, 
                            pos_SNP_filtered, 
                            highHetVarRegions, chr;
                            windowSize = 500)

# inspect values for mean IndHetStan per individual for that high HetVar region
plot(meanAcrossRegionIndHetStan)

# Add column to metadata containing the regionIndHetStan for this highHet region:
command = "ind_with_metadata_included." * chr * "_regionIndHetStan = meanAcrossRegionIndHetStan"
eval(Meta.parse(command)) # this executes the command constructed above
ind_with_metadata_included.regionIndHetStan = meanAcrossRegionIndHetStan

#names(ind_with_metadata_included)

# check whether missing data related to heterozygosity (good news: not really)
plot(ind_with_metadata_included.numMissings, meanAcrossRegionIndHetStan)

# PCA of all individuals:

genos_highHetVarRegion_imputed = Impute.svd(Matrix{Union{Missing, Float32}}(genos_highHetVarRegion))

flipPC1 = false
flipPC2 = false

PCAmodelAll = plotPCA(genos_highHetVarRegion_imputed, ind_with_metadata_included, 
            groups_to_plot_PCA, group_colors_PCA; 
            sampleSet = "greenish warblers", regionText = regionText,
            flip1 = flipPC1, flip2 = flipPC2,
            lineOpacity = 0.7, fillOpacity = 0.6,
            symbolSize = 14, showTitle = true,
            xLabelText = string("Region PC1"), yLabelText = string("Region PC2"),
            showPlot = false)

display(PCAmodelAll.PCAfig)

# Add PC values to metadata for individuals included in PCA above:
if flipPC1
    PCAmodelAll.metadata.PC1 = -1 .* PCAmodelAll.values[1,:]
else 
    PCAmodelAll.metadata.PC1 = PCAmodelAll.values[1,:]
end
if flipPC2
    PCAmodelAll.metadata.PC2 = -1 .* PCAmodelAll.values[2,:]
else
    PCAmodelAll.metadata.PC2 = PCAmodelAll.values[2,:]
end
PCAmodelAll.metadata.PC3 = PCAmodelAll.values[3,:]

# For the next bit to work with above, make sure that all individuals in the above `plotPCA` command
# are included in the `groups_to_plot_PCA`

# choose inds with low IndHet in high HetVar region:
indSelection_lowIndHetStan = (meanAcrossRegionIndHetStan .< 1.5) 

#Plot only the lowIndHetStan individuals:

f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title = "PC1 vs. PC2, only low heterozygosity",
    xlabel = "Region PC1", xlabelsize = 24,
    ylabel = "Region PC2", ylabelsize = 24,
    autolimitaspect = 1)
hidedecorations!(ax, label = false, ticklabels = false, ticks = false) # hide background lattice
for i in eachindex(groups_to_plot_PCA) 
    selection = (PCAmodelAll.metadata.Fst_group .== groups_to_plot_PCA[i]) .& indSelection_lowIndHetStan
    CairoMakie.scatter!(ax, PCAmodelAll.metadata.PC1[selection], PCAmodelAll.metadata.PC2[selection], marker = :diamond, color = (group_colors_PCA[i], 0.6), markersize = 14, strokewidth=0.5, strokecolor = ("black", 0.7))
end
display(f)




#= ind_with_metadata_lowIndHetStan = ind_with_metadata_included[indSelection, :]

genos_lowIndHetStan = genos_highHetVarRegion[indSelection, :]

# check that missing genotypes are encoded as `missing` rather than `-1`:
if sum(ismissing.(genos_lowIndHetStan)) == 0
    println("Warning: No `missing` genotypes to be imputed")
end

# impute missing genotypes:

genos_lowIndHetStan_imputed = Impute.svd(Matrix{Union{Missing, Float32}}(genos_lowIndHetStan))

flipPC1 = false
flipPC2 = false

PCAmodel = plotPCA(genos_lowIndHetStan_imputed, ind_with_metadata_lowIndHetStan, 
            groups_to_plot_PCA, group_colors_PCA; 
            sampleSet = "greenish warblers (lowIndHetStan)", regionText = regionText,
            flip1 = flipPC1, flip2 = flipPC2,
            lineOpacity = 0.7, fillOpacity = 0.6,
            symbolSize = 14, showTitle = true,
            xLabelText = string("Region PC1"), yLabelText = string("Region PC2"),
            showPlot = false)

display(PCAmodel.PCAfig)

# Add PC values to metadata for individuals included in PCA above:
if flipPC1
    PCAmodel.metadata.PC1 = -1 .* PCAmodel.values[1,:]
else 
    PCAmodel.metadata.PC1 = PCAmodel.values[1,:]
end
if flipPC2
    PCAmodel.metadata.PC2 = -1 .* PCAmodel.values[2,:]
else
    PCAmodel.metadata.PC2 = PCAmodel.values[2,:]
end
PCAmodel.metadata.PC3 = PCAmodel.values[3,:] =#

```

### Save the individual colors in the metadata

```{julia}
indColors = fill("", size(PCAmodelAll.metadata, 1))
for i in axes(PCAmodelAll.metadata, 1)
    indColors[i] = group_colors_PCA[findfirst(groups_to_plot_PCA .== PCAmodelAll.metadata.Fst_group[i])]
end
PCAmodelAll.metadata.indColorLeft = indColors
PCAmodelAll.metadata.indColorRight = indColors
```


# Plot PC1 vs. PC2:

```{julia}
f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title = "PC1 vs. PC2",
    xlabel = "Region PC1", xlabelsize = 24,
    ylabel = "Region PC2", ylabelsize = 24,
    autolimitaspect = 1)
hidedecorations!(ax, label = false, ticklabels = false, ticks = false) # hide background lattice
for i in eachindex(groups_to_plot_PCA) 
    selection = PCAmodelAll.metadata.Fst_group .== groups_to_plot_PCA[i]
    CairoMakie.scatter!(ax, PCAmodelAll.metadata.PC1[selection], PCAmodelAll.metadata.PC2[selection], marker = :diamond, color = (group_colors_PCA[i], 0.6), markersize = 14, strokewidth=0.5, strokecolor = ("black", 0.7))
end
display(f)
```

# Plot PC1 vs. PC3:

```{julia}
f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title = "PC1 vs. PC3",
    xlabel = "Region PC1", xlabelsize = 24,
    ylabel = "Region PC3", ylabelsize = 24,
    autolimitaspect = 1)
hidedecorations!(ax, label = false, ticklabels = false, ticks = false) # hide background lattice
for i in eachindex(groups_to_plot_PCA) 
    selection = PCAmodelAll.metadata.Fst_group .== groups_to_plot_PCA[i]
    CairoMakie.scatter!(ax, PCAmodelAll.metadata.PC1[selection], PCAmodelAll.metadata.PC3[selection], marker = :diamond, color = (group_colors_PCA[i], 0.6), markersize = 14, strokewidth=0.5, strokecolor = ("black", 0.7))
end
display(f)
```

# At chr 26 high HetVar region, there are only 5 clear haplogroups (one green is somewhat away). Divide samples into those groups, based on PCA scores, and then calculate pi within and pi between

```{julia}
# Inspect chromosome 26 PCA of low IndHet (< 1.5) individuals,
# and specify group boundaries:

clusterNames = ["virLud",
                "nit",
                "troch",
                "obs",
                "plumb"]

clusterColors = ["green",
                "grey",
                "yellow",
                "orange",
                "red"]

virLud = (PCAmodelAll.metadata.PC1 .< -5.5) .& indSelection_lowIndHetStan
nit = (-5.5 .< PCAmodelAll.metadata.PC1 .< -4) .& indSelection_lowIndHetStan
troch = (PCAmodelAll.metadata.PC2 .< -6) .& indSelection_lowIndHetStan
obs = (-6 .< PCAmodelAll.metadata.PC2 .< -4) .& indSelection_lowIndHetStan
plumb = (6 .< PCAmodelAll.metadata.PC1) .& (2 .< PCAmodelAll.PC2) .& indSelection_lowIndHetStan

# check the individuals in each group
PCAmodelAll.metadata.Fst_group[virLud]
PCAmodelAll.metadata.Fst_group[nit]
PCAmodelAll.metadata.Fst_group[troch]
PCAmodelAll.metadata.Fst_group[obs]
PCAmodelAll.metadata.Fst_group[plumb]

clusterArray = [virLud nit troch obs plumb]

# show numbers in each group
println("The numbers in each group are $(sum(clusterArray, dims=1)) and the sum of those is $(sum(sum(clusterArray, dims=1)))")

# create vectors that indicate the groups and plot order for this analysis:
clusterMembership = fill("none", nrow(PCAmodelAll.metadata))
plotOrder = fill(-9, nrow(PCAmodelAll.metadata))
for i in eachindex(clusterArray[1,:])
    clusterMembership[clusterArray[:,i]] .= clusterNames[i]
    plotOrder[clusterArray[:,i]] .= i
end

# Calculate allele freqs and sample sizes
freqs, sampleSizes = getFreqsAndSampleSizes(genos_highHetVarRegion, clusterMembership, clusterNames)
println("Calculated population allele frequencies and sample sizes")

# Calculate per-site pi (within-group nucleotide distance)

sitePi = getSitePi(freqs, sampleSizes)

# calculate pairwise Dxy per site, using data in "freqs" and groups in "groups"

Dxy, pairwiseDxyClusterNames = getDxy(freqs, clusterNames)

Fst, FstNumerator, FstDenominator, pairwiseFstClusterNames = getFst(freqs, sampleSizes, clusterNames; among=false)  # set among to FALSE if no among Fst wanted (some things won't work without it) 

# Now get averages of pi and Dxy for whole region:

regionPiTable = DataFrame(cluster = clusterNames, pi = getRegionPi(sitePi))
#= 5×2 DataFrame
 Row │ cluster  pi         
     │ String   Float64    
─────┼─────────────────────
   1 │ virLud   0.0135205
   2 │ nit      0.00548557
   3 │ troch    0.00975861
   4 │ obs      0.00902527
   5 │ plumb    0.00510553 =#

regionDxyTable = DataFrame(cluster_pair = pairwiseDxyClusterNames, Dxy = getRegionDxy(Dxy))
#= 10×2 DataFrame
 Row │ cluster_pair  Dxy       
     │ String        Float64   
─────┼─────────────────────────
   1 │ virLud_nit    0.0243846
   2 │ virLud_troch  0.0324256
   3 │ virLud_obs    0.0332749
   4 │ virLud_plumb  0.0390193
   5 │ nit_troch     0.0341654
   6 │ nit_obs       0.0344734
   7 │ nit_plumb     0.0403857
   8 │ troch_obs     0.0176458
   9 │ troch_plumb   0.0296574
  10 │ obs_plumb     0.0300157 =#

# Make a genotype-by-individual plot using all variable loci in the region,
missingFractionAllowed = 0.1
# in metadata, replace `Fst_group` column with cluster info (needed for the function below):
PCAmodelAll.metadata.Fst_group = clusterMembership
PCAmodelAll.metadata.plot_order = plotOrder

# limit the SNPs to those with variants greater than 50% in 
# at least one pop, and less than 50% in at least one pop.
# (So for each column in `freqs`, the maximum should be > 0.5 
# and the minimum should be < 0.5)
selectedSNPs = (vec(maximum(freqs, dims=1)) .> 0.5) .& (vec(minimum(freqs, dims=1)) .< 0.5)
genos_selectedSNPs = genos_highHetVarRegion[:, selectedSNPs]
pos_selectedSNPs = pos_highHetVarRegion[selectedSNPs, :]
Fst_selectedSNPs = Fst[:, selectedSNPs]
freqs_selectedSNPs = freqs[:, selectedSNPs]

# limit the number of individuals per group to plot
numIndsToPlot = [15, 15, 15, 15, 15, 15]

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNames, numIndsToPlot, 
                                            genos_selectedSNPs, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs, clusterNames, clusterColors;
                missingFractionAllowed = missingFractionAllowed,
                indColorRightProvided = true)
```

## Now show a GBI plot like above, but with heterozygotes:

```{julia}

clusterNamesWithHets = ["virLud",
                        "nit",
                        "virLud_troch",
                        "troch",
                        "obs",
                        "obs_plumb",
                        "plumb",
                        "vir_plumb"]

clusterColorsWithHets = ["blue",
                        "grey",
                        "yellowgreen",
                        "yellow",
                        "orange",
                        "darkorange1",
                        "red",
                        "purple"]

#= clusterNamesHets = ["virLud_troch",
                    "obs_plumb",
                    "vir_plumb"]

clusterColorsHets = ["yellowgreen",
                    "orangered",
                    "purple"] =#

virLud_troch = (-5.5 .< PCAmodelAll.metadata.PC1 .< -2.2) .&
                (-4 .< PCAmodelAll.metadata.PC2 .< 2) .&
                 .!indSelection_lowIndHetStan
obs_plumb = (2.5 .< PCAmodelAll.metadata.PC1 .< 5) .&
                (-3.5 .< PCAmodelAll.metadata.PC2 .< -1.5) .&
                 .!indSelection_lowIndHetStan
vir_plumb = (-2 .< PCAmodelAll.metadata.PC1 .< 3) .&
                (2.5 .< PCAmodelAll.metadata.PC2 .< 5) .&
                 .!indSelection_lowIndHetStan

# check the individuals in each group
PCAmodelAll.metadata.Fst_group[virLud]
PCAmodelAll.metadata.Fst_group[nit]
PCAmodelAll.metadata.Fst_group[virLud_troch]
PCAmodelAll.metadata.Fst_group[troch]
PCAmodelAll.metadata.Fst_group[obs]
PCAmodelAll.metadata.Fst_group[obs_plumb]
PCAmodelAll.metadata.Fst_group[plumb]
PCAmodelAll.metadata.Fst_group[vir_plumb]

clusterArray = [virLud nit virLud_troch troch obs obs_plumb plumb vir_plumb]

sum(clusterArray, dims=1)

if sum(sum(clusterArray, dims=1)) == size(PCAmodelAll.metadata, 1)
    println("Good news: Individuals included in a group matches total number of individuals")
end

# create vectors that indicate the groups and plot order for this analysis:
clusterMembershipWithHets = fill("none", nrow(PCAmodelAll.metadata))
plotOrderWithHets = fill(-9, nrow(PCAmodelAll.metadata))
for i in eachindex(clusterArray[1,:])
    clusterMembershipWithHets[clusterArray[:,i]] .= clusterNamesWithHets[i]
    plotOrderWithHets[clusterArray[:,i]] .= i
end

# Add column to main metadata object containing the cluster membership for this highHet region:
command = "ind_with_metadata_included." * chr * "_cluster = clusterMembershipWithHets"
eval(Meta.parse(command)) # this executes the command constructed above

# in metadata, replace `Fst_group` column with cluster info (needed for the function below):
PCAmodelAll.metadata.Fst_group = clusterMembershipWithHets
PCAmodelAll.metadata.plot_order = plotOrderWithHets

# limit the number of individuals per group to plot
numIndsToPlotWithHets = [15, 15, 15, 15, 15, 15, 15, 15, 15]

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNamesWithHets, numIndsToPlotWithHets, 
                                            genos_selectedSNPs, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs, clusterNamesWithHets, clusterColorsWithHets;
                missingFractionAllowed = missingFractionAllowed,
                indColorLeftProvided = false,
                indColorRightProvided = true)
```


## Show just the west area (without nitidus)

```{julia}

clusterNamesWithHetsWest = ["virLud",
                        "virLud_troch",
                        "troch"]

clusterColorsWithHetsWest = ["blue",
                        "yellowgreen",
                        "yellow"]

# limit the SNPs to those with variants greater than 50% in 
# at least one pop, and less than 50% in at least one pop.
# (So for each column in `freqs`, the maximum should be > 0.5 
# and the minimum should be < 0.5)
# Calculate allele freqs and sample sizes
freqs, sampleSizes = getFreqsAndSampleSizes(genos_selectedSNPs, clusterMembershipWithHets, clusterNamesWithHetsWest)
println("Calculated population allele frequencies and sample sizes")
selectedSNPs = (vec(maximum(freqs, dims=1)) .> 0.5) .& (vec(minimum(freqs, dims=1)) .< 0.5)
genos_selectedSNPs2 = genos_selectedSNPs[:, selectedSNPs]
pos_selectedSNPs2 = pos_selectedSNPs[selectedSNPs, :]
freqs_selectedSNPs2 = freqs[:, selectedSNPs]

numIndsToPlotWithHets = [100, 100, 100]

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNamesWithHetsWest, numIndsToPlotWithHets, 
                                            genos_selectedSNPs2, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs2,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs2, clusterNamesWithHetsWest, clusterColorsWithHetsWest;
                missingFractionAllowed = missingFractionAllowed,
                indColorLeftProvided = false,
                indColorRightProvided = true)

```


## Show just the east area

```{julia}

clusterNamesWithHetsWest = ["troch",
                            "obs",
                            "obs_plumb",
                            "plumb",]

clusterColorsWithHetsWest = ["yellow",
                            "orange",
                            "darkorange1",
                            "red"]

# limit the SNPs to those with variants greater than 50% in 
# at least one pop, and less than 50% in at least one pop.
# (So for each column in `freqs`, the maximum should be > 0.5 
# and the minimum should be < 0.5)
# Calculate allele freqs and sample sizes
freqs, sampleSizes = getFreqsAndSampleSizes(genos_selectedSNPs, clusterMembershipWithHets, clusterNamesWithHetsWest)
println("Calculated population allele frequencies and sample sizes")
selectedSNPs = (vec(maximum(freqs, dims=1)) .> 0.5) .& (vec(minimum(freqs, dims=1)) .< 0.5)
genos_selectedSNPs2 = genos_selectedSNPs[:, selectedSNPs]
pos_selectedSNPs2 = pos_selectedSNPs[selectedSNPs, :]
freqs_selectedSNPs2 = freqs[:, selectedSNPs]

numIndsToPlotWithHets = [100, 100, 100, 100]

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNamesWithHetsWest, numIndsToPlotWithHets, 
                                            genos_selectedSNPs2, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs2,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs2, clusterNamesWithHetsWest, clusterColorsWithHetsWest;
                missingFractionAllowed = missingFractionAllowed,
                indColorLeftProvided = false,
                indColorRightProvided = true)

```

## Show just the northern area

```{julia}

clusterNamesWithHetsWest = ["virLud",
                            "vir_plumb",
                            "plumb"]

clusterColorsWithHetsWest = ["blue",
                            "purple",
                            "red"]

# limit the SNPs to those with variants greater than 50% in 
# at least one pop, and less than 50% in at least one pop.
# (So for each column in `freqs`, the maximum should be > 0.5 
# and the minimum should be < 0.5)
# Calculate allele freqs and sample sizes
freqs, sampleSizes = getFreqsAndSampleSizes(genos_selectedSNPs, clusterMembershipWithHets, clusterNamesWithHetsWest)
println("Calculated population allele frequencies and sample sizes")
selectedSNPs = (vec(maximum(freqs, dims=1)) .> 0.5) .& (vec(minimum(freqs, dims=1)) .< 0.5)
genos_selectedSNPs2 = genos_selectedSNPs[:, selectedSNPs]
pos_selectedSNPs2 = pos_selectedSNPs[selectedSNPs, :]
freqs_selectedSNPs2 = freqs[:, selectedSNPs]

numIndsToPlotWithHets = [100, 100, 100]

genosForGBI, indMetadataforGBI = limitIndsToPlot(clusterNamesWithHetsWest, numIndsToPlotWithHets, 
                                            genos_selectedSNPs2, PCAmodelAll.metadata;
                                            sortByMissing = true)

plotGenotypeByIndividual(regionInfo, pos_selectedSNPs2,
                genosForGBI, indMetadataforGBI, freqs_selectedSNPs2, clusterNamesWithHetsWest, clusterColorsWithHetsWest;
                missingFractionAllowed = missingFractionAllowed,
                indColorLeftProvided = false,
                indColorRightProvided = true)

```


## Make a summary plot for the cluster types at different chromosome haploblocks (west without nitidus)

Will modify the plotGenotypeByIndividual() function, but need to construct a genotype data structure based on the groups (determined above) for each haploblock.

For west side (without nitidus):

```{julia}
HaploblockRegions = ["gw15","gw26", "gw28"]
numHaploblockRegions = length(HaploblockRegions)
numInds = size(ind_with_metadata_included, 1)
# create genotype object and fill with missing (-1) genotypes
genosSummary = fill(-1, (numInds, numHaploblockRegions)) 
# fill object with appropriate genotypes
i = 1 # doing this so I can later build a loop on this logic
    #gw15:
    genosSummary[ind_with_metadata_included.gw15_cluster .== "virLud", i] .= 0
    genosSummary[ind_with_metadata_included.gw15_cluster .== "virLud_troch", i] .= 1
    genosSummary[ind_with_metadata_included.gw15_cluster .== "troch", i] .= 2
i = 2 #gw26:
    genosSummary[ind_with_metadata_included.gw26_cluster .== "virLud", i] .= 0
    genosSummary[ind_with_metadata_included.gw26_cluster .== "virLud_troch", i] .= 1
    genosSummary[ind_with_metadata_included.gw26_cluster .== "troch", i] .= 2
i = 3 #gw28:
    genosSummary[ind_with_metadata_included.gw28_cluster .== "virLud", i] .= 0
    genosSummary[ind_with_metadata_included.gw28_cluster .== "virLud_troch", i] .= 1
    genosSummary[ind_with_metadata_included.gw28_cluster .== "troch", i] .= 2

plotGroupsForSummary = ["vir","vir_S","lud_PK", "lud_KS", "lud_central", "lud_Sath", "lud_ML","troch_west","troch_LN"]
groupColorsForSummary = ["blue","turquoise1","seagreen4","seagreen3","seagreen2","olivedrab3","olivedrab2","olivedrab1","yellow"] 

plotHaploblockSummary(genosSummary, ind_with_metadata_included,
                            plotGroupsForSummary, groupColorsForSummary;
                            regionNames = HaploblockRegions,
                            indFontSize = 8, figureSize = (1200, 1600),
                            plotTitle = nothing,
                            indColorLeftProvided = false,
                            indColorRightProvided = false)

#= # For debugging function:

indMetadata = ind_with_metadata_included
plotGroups = plotGroupsForSummary
plotGroupColors = groupColorsForSummary
regionNames = HaploblockRegions
indFontSize = 10
figureSize = (1200, 1200)
plotTitle = nothing
indColorLeftProvided = false
indColorRightProvided = false =#

"""
    plotHaploblockSummary(genosSummary, indMetadata,
                            plotGroups, plotGroupColors;
                            regionNames,
                            indFontSize=10, figureSize=(1200, 1200),
                            plotTitle = nothing,
                            indColorLeftProvided = false,
                            indColorRightProvided = false)

Construct a genotype-by-individual plot, with option to filter out SNPs with too much missing data. 

Under the default setting, alleles are colored (dark purple vs. light purple) according to whichever allele is designated as `group1`. 

​# Arguments

- `genosSummary`: Matrix containing summary genotype data (individuals in rows, loci in columns).
- `indMetadata`: Matrix of metadata for individuals; must contain `Fst_group` and `plot_order` columns.
- `plotGroups`: Vector of group names to include in plot.
- `plotGroupColors`: Vector of plotting colors corresponding to the groups.
- `regionNames`: Optional; Names of the genotyped regions.
- `indFontSize`: Optional; the font size of the individual ID labels.
- `figureSize`: Optional; the size of the figure; default is `(1200, 1200)`.  
- `plotTitle`: Optional; default will make a title. For no title, set to `""`.
- `indColorLeftProvided`: Optional; Default is `false`. Set to `true` if there is a column labeled `indColorLeft` in the metadata providing color of each individual for plotting on left side.
- `indColorRightProvided`: Optional; same as above but for right side (requires `indColorRight` column in metadata).

# Notes
Returns a tuple containing:
- the figure
- the plotted genotypes
- the sorted metadata matrix for the plotted individuals
"""
function plotHaploblockSummary(genosSummary, indMetadata,
                                plotGroups, plotGroupColors;
                                regionNames = nothing,        
                                indFontSize=10, figureSize=(1200, 1200),
                                plotTitle = nothing,
                                indColorLeftProvided = false,
                                indColorRightProvided = false)
    
    # if the genoData has missing values, then convert to -1:
    genosSummary[ismissing.(genosSummary)] .= -1

    numRegions = size(genosSummary, 2)

    genosSummary_subset = genosSummary[indMetadata.Fst_group .∈ Ref(plotGroups), :]
    indMetadata_subset = indMetadata[indMetadata.Fst_group .∈ Ref(plotGroups), :]

    # Choose sorting order by plot_order column in input metadata file

    sorted_genosSummary_subset = genosSummary_subset[sortperm(indMetadata_subset.plot_order, rev=false), :]
    numInds = size(sorted_genosSummary_subset, 1)
    sorted_indMetadata_subset = indMetadata_subset[sortperm(indMetadata_subset.plot_order, rev=false), :]

    # Set up the plot window:
    f = CairoMakie.Figure(size=figureSize)

    if isnothing(plotTitle)
        plotTitle = "Summary of $numRegions haploblock genotypes for $numInds individuals"
    end 

    # Set up the main Axis: 
    ax = Axis(f[1, 1],
        title = plotTitle,
        titlesize=30,
        limits=(0.5 - 0.09 * (numRegions), 0.5 + 1.09 * (numRegions),
            0.5 - 0.3 * numInds, 0.5 + numInds)
    )
    hidedecorations!(ax) # hide background lattice and axis labels
    hidespines!(ax) # hide box around plot

    genotypeColors = ["#3f007d", "#807dba", "#dadaeb", "grey50"]  # purple shades from colorbrewer

    # plot evenly spaced by SNP order along chromosome:
    # make top part of fig (genotypes for individuals)
    labelCushion = numRegions / 100
    label_x_left = 0.5 - labelCushion
    label_x_right = 0.5 + numRegions + labelCushion
    colorBoxCushion = 0.07 * numRegions
    groupColorBox_x_left = 0.5 - colorBoxCushion
    groupColorBox_x_right = 0.5 + numRegions + colorBoxCushion
    boxWidth = 0.005 * numRegions * 2
    groupColorBox_x_left = [-boxWidth, -boxWidth, boxWidth, boxWidth, -boxWidth] .+ groupColorBox_x_left
    groupColorBox_x_right = [-boxWidth, -boxWidth, boxWidth, boxWidth, -boxWidth] .+ groupColorBox_x_right
    groupColorBox_y = [0.4, -0.4, -0.4, 0.4, 0.4]

    for i in 1:numInds
        y = numInds + 1 - i  # y is location for plotting; this reverses order of plot top-bottom
        labelText = last(split(sorted_indMetadata_subset.ID[i], "_"))  # this gets the last part of the sample ID (usually the main ID part)
        # put sample label on left side:
        CairoMakie.text!(label_x_left, y; text=labelText, align=(:right, :center), fontsize=indFontSize)
        # put sample label on left side:
        CairoMakie.text!(label_x_right, y; text=labelText, align=(:left, :center), fontsize=indFontSize)
        if indColorLeftProvided
            boxColorLeft = sorted_indMetadata_subset.indColorLeft[i]
        else
            boxColorLeft = plotGroupColors[findfirst(plotGroups .== sorted_indMetadata_subset.Fst_group[i])]
        end
        if indColorRightProvided
            boxColorRight = sorted_indMetadata_subset.indColorRight[i]
        else
            boxColorRight = plotGroupColors[findfirst(plotGroups .== sorted_indMetadata_subset.Fst_group[i])]
        end
        CairoMakie.poly!(Point2f.(groupColorBox_x_left, (y .+ groupColorBox_y)), color=boxColorLeft)
        CairoMakie.poly!(Point2f.(groupColorBox_x_right, (y .+ groupColorBox_y)), color=boxColorRight)
    end

    # generate my own plotting symbol (a rectangle)
    box_x = [-0.45, -0.45, 0.45, 0.45, -0.45]
    #box_x = [-0.5, -0.5, 0.5, 0.5, -0.5]
    box_y = [0.4, -0.4, -0.4, 0.4, 0.4]
    # generate triangles for plotting heterozygotes
    triangle1_x = [-0.45, -0.45, 0.45, -0.45]
    #triangle1_x = [-0.5, -0.5, 0.5, -0.5]
    triangle1_y = [0.4, -0.4, 0.4, 0.4]
    triangle2_x = [-0.45, 0.45, 0.45, -0.45]
    #triangle2_x = [-0.5, 0.5, 0.5, -0.5]
    triangle2_y = [-0.4, -0.4, 0.4, -0.4]
    # cycle through individuals, graphing each type of genotype:
    for i in 1:numInds
        y = numInds + 1 - i  # y is location for plotting; this reverses order of plot top-bottom
        #CairoMakie.lines!([0.5, numRegions + 0.5], [y, y], color="grey40") # for lines across the individual rows
        genotypes = sorted_genosSummary_subset[i, :]
        hom_ref_locs = findall(genotypes .== 0)
        if length(hom_ref_locs) > 0
            for j in eachindex(hom_ref_locs)
                CairoMakie.poly!(Point2f.((hom_ref_locs[j] .+ box_x), (y .+ box_y)), color=genotypeColors[1])
            end
        end
        het_locs = findall(genotypes .== 1)
        if length(het_locs) > 0
            for j in eachindex(het_locs)
                CairoMakie.poly!(Point2f.((het_locs[j] .+ triangle1_x), (y .+ triangle1_y)), color=genotypeColors[1])
                CairoMakie.poly!(Point2f.((het_locs[j] .+ triangle2_x), (y .+ triangle2_y)), color=genotypeColors[3])
            end
        end
        hom_alt_locs = findall(genotypes .== 2)
        if length(hom_alt_locs) > 0
            for j in eachindex(hom_alt_locs)
                CairoMakie.poly!(Point2f.((hom_alt_locs[j] .+ box_x), (y .+ box_y)), color=genotypeColors[3])
            end
        end
    end

    if isnothing(regionNames)
        regionNames = string.(1:numRegions)
    end

    # make labels on lower part
    y_label = 0.5 - 0.1numInds
    for i in 1:numRegions
        CairoMakie.text!(i, y_label; text = regionNames[i], align=(:center, :center), fontsize=30)
    end

    display(f)

    return f, sorted_genosSummary_subset, sorted_indMetadata_subset
end
```



### OLD STUFF BELOW (CAN PROBABLY DELETE, BUT MIGHT BE SOME GOOD BITS TO KEEP)


### Actually new plan: Just do the PCA on all individuals, then show a graph without the heterozygotes. Will do this above.

# Adding 28June2024: starting with PCA of just the homozygotes (above), apply those axes to other individuals to add them to the PCA:

```{julia}

ind_with_metadata_included # this is the list of all individuals prior to choosing low IndHet

genos_highHetVarRegion_imputed # these are the genotypes of all individuals (imputed)


# the key command, from another place in my code (to expand to multiple samples, matrix should have individuals as columns):
matrixForPCAplot = Matrix{Float32}(transpose(genos_highHetVarRegion_imputed))
PCvalues = transpose(predict(PCAmodel.model, matrixForPCAplot))

f = CairoMakie.Figure()
ax = Axis(f[1, 1],
    title = "PC1 vs. PC2",
    xlabel = "Region PC1", xlabelsize = 24,
    ylabel = "Region PC2", ylabelsize = 24,
    autolimitaspect = 1)
hidedecorations!(ax, label = false, ticklabels = false, ticks = false) # hide background lattice
for i in eachindex(groups_to_plot_PCA) 
    selection = ind_with_metadata_included.Fst_group .== groups_to_plot_PCA[i]
    CairoMakie.scatter!(ax, PCvalues[selection, 1], PCvalues[selection, 2], marker = :diamond, color = (group_colors_PCA[i], 0.6), markersize = 14, strokewidth=0.5, strokecolor = ("black", 0.7))
end
display(f)

```

##########


# Below, what I tried first here is to calculate a matrix of pairwise genetic distances and then use Principal Coordinates Analysis (Metric Multidimensional Scaling). The below works. Then I realized that it is perhaps better to stick with PCA like in the rest of the paper. So will do that above.

```{julia}
indGenDistances = getIndGenDistances(genos_lowIndHetStan)

mds = fit(MDS, indGenDistances; distances=true)
pco_coords = predict(mds)
PCO1 = pco_coords[1,:]
PCO2 = pco_coords[2,:]
PCO3 = pco_coords[3,:]
PCO4 = pco_coords[4,:]


plot(PCO1, PCO2)

#plot(PCO1, PCO3)

#plot(PCO1, PCO4)

pcoResults = DataFrame(ind = ind_with_metadata_lowIndHetStan.ind, Fst_group = ind_with_metadata_lowIndHetStan.Fst_group, PCo1 = PCO1, PCo2 = PCO2)

# code taken from SNPlots.plotPCA :
autolimitaspect_setting = 1; lineOpacity = 0.8; fillOpacity = 0.2;
    symbolSize = 10; plotTitle = "PCo plot"; showTitle = true;
    xLabelText = "Genomic PC1"; yLabelText = "Genomic PC2";
    labelSize = 24

ind_with_metadata_forPlot = ind_with_metadata_lowIndHetStan
PC1 = PCO1; PC2 = PCO2

f = CairoMakie.Figure()
ax = Axis(f[1, 1],
            title = plotTitle,
            xlabel = xLabelText, xlabelsize = labelSize,
            ylabel = yLabelText, ylabelsize = labelSize,
            autolimitaspect = autolimitaspect_setting)
hidedecorations!(ax, label = false, ticklabels = false, ticks = false) # hide background lattice
for i in eachindex(groups_to_plot_PCA) 
    selection = ind_with_metadata_forPlot.Fst_group .== groups_to_plot_PCA[i]
    CairoMakie.scatter!(ax, PC1[selection], PC2[selection], marker = :diamond, color = (group_colors_PCA[i], fillOpacity), markersize = symbolSize, strokewidth=0.5, strokecolor = ("black", lineOpacity))
end
display(f)

```

#### Notes: 
# - Get all samples with regionIndHetStan .< 0.75 (or maybe another value)
# - Construct distance matrix
# - Do PCoA on distance matrix (also known as Metric Multidimensional Scaling)
# mds = fit(MDS, D; distances=true, maxoutdim=size(D,1)-1)
# https://juliastats.org/MultivariateStats.jl/dev/mds/

# Pick a small set of individuals to examine genetic distances

```{julia}
# for demonstration haplotypes, choose individuals with numMissings < 200_000
# and regionIndHetStan < 0.5:

selection = (ind_with_metadata_included.numMissings .< 200_000) .& (ind_with_metadata_included.regionIndHetStan .< 0.75)

ind_with_metadata_haplotypeCandidates = ind_with_metadata_included[selection, :]

# But the above cuts out the obscuratus and nitidus individuals (which have about 700k missing genome-wide at least in early filtering calculations)
# So don't worry about missings for now--just sort and choose low ones for each haplogroup:

# GW_Armando_plate2_TTGW73  #lud_Sath

# GW_Armando_plate2_LN2 #troch_LN

# GW_Armando_plate2_TTGW-15-04 #lud_Sural

# GW_Armando_plate1_JG02G02 #plumb

# GW_Armando_plate2_JE31G01 #vir

# GW_Armando_plate1_RF20G01 #plumb_BJ

# GW_Lane5_TU1 #nit

indsToChoose = ["GW_Armando_plate2_TTGW73",
                "GW_Armando_plate2_LN2",
                "GW_Armando_plate2_TTGW-15-04",
                "GW_Armando_plate1_JG02G02",
                "GW_Armando_plate2_JE31G01",
                "GW_Armando_plate1_RF20G01",
                "GW_Lane5_TU1"]

selection = map(in(indsToChoose), ind_with_metadata_included.ind)
filtered_in = ind_with_metadata_included.ind[selection]
ind_with_metadata_chosenInds = ind_with_metadata_included[selection, :]
geno_indFiltered = view(genotypes_region, selection, :)
println("Specific individuals chosen as requested: ")
display(filtered_in)

# choose the loci in the high HetVar region:

selection = (positionMin .< pos_region.position .< positionMax)

geno_indFiltered_highHetVarRegion = geno_indFiltered[:, selection]

# put in plot order:

indexOrder = sortperm(ind_with_metadata_chosenInds.plot_order)
geno_indFiltered_highHetVarRegion_ordered = geno_indFiltered_highHetVarRegion[indexOrder, :]
ind_with_metadata_chosenInds_ordered = ind_with_metadata_chosenInds[indexOrder, :]

# ABOVE HAVE GENOTYPES FOR JUST THESE INDIVIDUALS IN JUST THE HIGH HETVAR REGION ON THE ONE CHR. NEXT DO GENETIC DISTANCE BETWEEN ALL PAIRS OF INDIVIDUALS FOR THIS REGION. 
# count mismatches and divide by total number of sites.
# mismatches of genotype 0 to genotype 2 count as 1 mismatch.
# genotype 0 or 2 to genotype 1 (het) counts as 0.5 mismatch.
# genotype 1 to genotype 1 counts as 0 mismatch (debatable whether it should be 0 or 0.5, but I want F1 hybrids to not have distance between them).

function getIndGenDistances(genotypeMatrix)
    genotypeMatrix[ismissing.(genotypeMatrix)] .= -1 # converts `missing` to -1
    numInds = size(genotypeMatrix)[1]
    distanceMatrix = Matrix{Float64}(undef, numInds, numInds)
    for i in 1:numInds
        for j in 1:numInds
            firstGeno = genotypeMatrix[i,:]
            secondGeno = genotypeMatrix[j,:]
            fullMismatches = sum((firstGeno .== 0 .&& secondGeno .== 2) .||
                                (firstGeno .== 2 .&& secondGeno .== 0))
            partialMismatches = sum((firstGeno .== 0 .&& secondGeno .== 1) .|| 
                                    (firstGeno .== 1 .&& secondGeno .== 0) .|| 
                                    (firstGeno .== 2 .&& secondGeno .== 1) .|| 
                                    (firstGeno .== 1 .&& secondGeno .== 2))
            bothHet = sum(firstGeno .== 1 .&& secondGeno .== 1)
            nonMissingGenotypes = sum((firstGeno .!= -1) .&& (secondGeno .!= -1))
            distanceMatrix[i,j] = (fullMismatches + 0.5partialMismatches + 0*bothHet) / nonMissingGenotypes
        end
    end
    return distanceMatrix
end

indGenDistances = getIndGenDistances(geno_indFiltered_highHetVarRegion_ordered)

mds = fit(MDS, indGenDistances; distances=true)
pco_coords = predict(mds)
PCO1 = pco_coords[1,:]
PCO2 = pco_coords[2,:]

plot(PCO1, PCO2)

```